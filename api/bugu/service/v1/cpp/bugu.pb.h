// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bugu.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bugu_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bugu_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/annotations.pb.h"
#include "protoc-gen-openapiv2/options/annotations.pb.h"
#include "validate/validate.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bugu_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bugu_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[28]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bugu_2eproto;
namespace bugu {
namespace service {
namespace v1 {
class ConfusionReply;
struct ConfusionReplyDefaultTypeInternal;
extern ConfusionReplyDefaultTypeInternal _ConfusionReply_default_instance_;
class ConfusionRequest;
struct ConfusionRequestDefaultTypeInternal;
extern ConfusionRequestDefaultTypeInternal _ConfusionRequest_default_instance_;
class DeleteArtifactMetadataReply;
struct DeleteArtifactMetadataReplyDefaultTypeInternal;
extern DeleteArtifactMetadataReplyDefaultTypeInternal _DeleteArtifactMetadataReply_default_instance_;
class DeleteArtifactMetadataRequest;
struct DeleteArtifactMetadataRequestDefaultTypeInternal;
extern DeleteArtifactMetadataRequestDefaultTypeInternal _DeleteArtifactMetadataRequest_default_instance_;
class DeleteFileMetadataReply;
struct DeleteFileMetadataReplyDefaultTypeInternal;
extern DeleteFileMetadataReplyDefaultTypeInternal _DeleteFileMetadataReply_default_instance_;
class DeleteFileMetadataRequest;
struct DeleteFileMetadataRequestDefaultTypeInternal;
extern DeleteFileMetadataRequestDefaultTypeInternal _DeleteFileMetadataRequest_default_instance_;
class DetectReply;
struct DetectReplyDefaultTypeInternal;
extern DetectReplyDefaultTypeInternal _DetectReply_default_instance_;
class DetectRequest;
struct DetectRequestDefaultTypeInternal;
extern DetectRequestDefaultTypeInternal _DetectRequest_default_instance_;
class GetArtifactMetadataByFileIdReply;
struct GetArtifactMetadataByFileIdReplyDefaultTypeInternal;
extern GetArtifactMetadataByFileIdReplyDefaultTypeInternal _GetArtifactMetadataByFileIdReply_default_instance_;
class GetArtifactMetadataByFileIdRequest;
struct GetArtifactMetadataByFileIdRequestDefaultTypeInternal;
extern GetArtifactMetadataByFileIdRequestDefaultTypeInternal _GetArtifactMetadataByFileIdRequest_default_instance_;
class GetArtifactMetadataReply;
struct GetArtifactMetadataReplyDefaultTypeInternal;
extern GetArtifactMetadataReplyDefaultTypeInternal _GetArtifactMetadataReply_default_instance_;
class GetArtifactMetadataRequest;
struct GetArtifactMetadataRequestDefaultTypeInternal;
extern GetArtifactMetadataRequestDefaultTypeInternal _GetArtifactMetadataRequest_default_instance_;
class GetCurrentUserReply;
struct GetCurrentUserReplyDefaultTypeInternal;
extern GetCurrentUserReplyDefaultTypeInternal _GetCurrentUserReply_default_instance_;
class GetCurrentUserRequest;
struct GetCurrentUserRequestDefaultTypeInternal;
extern GetCurrentUserRequestDefaultTypeInternal _GetCurrentUserRequest_default_instance_;
class GetFileMetaByUserIdReply;
struct GetFileMetaByUserIdReplyDefaultTypeInternal;
extern GetFileMetaByUserIdReplyDefaultTypeInternal _GetFileMetaByUserIdReply_default_instance_;
class GetFileMetaByUserIdRequest;
struct GetFileMetaByUserIdRequestDefaultTypeInternal;
extern GetFileMetaByUserIdRequestDefaultTypeInternal _GetFileMetaByUserIdRequest_default_instance_;
class GetFileMetaReply;
struct GetFileMetaReplyDefaultTypeInternal;
extern GetFileMetaReplyDefaultTypeInternal _GetFileMetaReply_default_instance_;
class GetFileMetaRequest;
struct GetFileMetaRequestDefaultTypeInternal;
extern GetFileMetaRequestDefaultTypeInternal _GetFileMetaRequest_default_instance_;
class LoginReply;
struct LoginReplyDefaultTypeInternal;
extern LoginReplyDefaultTypeInternal _LoginReply_default_instance_;
class LoginRequest;
struct LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginRequest_User;
struct LoginRequest_UserDefaultTypeInternal;
extern LoginRequest_UserDefaultTypeInternal _LoginRequest_User_default_instance_;
class RegisterReply;
struct RegisterReplyDefaultTypeInternal;
extern RegisterReplyDefaultTypeInternal _RegisterReply_default_instance_;
class RegisterRequest;
struct RegisterRequestDefaultTypeInternal;
extern RegisterRequestDefaultTypeInternal _RegisterRequest_default_instance_;
class RegisterRequest_User;
struct RegisterRequest_UserDefaultTypeInternal;
extern RegisterRequest_UserDefaultTypeInternal _RegisterRequest_User_default_instance_;
class UpdateUserReply;
struct UpdateUserReplyDefaultTypeInternal;
extern UpdateUserReplyDefaultTypeInternal _UpdateUserReply_default_instance_;
class UpdateUserRequest;
struct UpdateUserRequestDefaultTypeInternal;
extern UpdateUserRequestDefaultTypeInternal _UpdateUserRequest_default_instance_;
class UpdateUserRequest_User;
struct UpdateUserRequest_UserDefaultTypeInternal;
extern UpdateUserRequest_UserDefaultTypeInternal _UpdateUserRequest_User_default_instance_;
class UserStruct;
struct UserStructDefaultTypeInternal;
extern UserStructDefaultTypeInternal _UserStruct_default_instance_;
}  // namespace v1
}  // namespace service
}  // namespace bugu
PROTOBUF_NAMESPACE_OPEN
template<> ::bugu::service::v1::ConfusionReply* Arena::CreateMaybeMessage<::bugu::service::v1::ConfusionReply>(Arena*);
template<> ::bugu::service::v1::ConfusionRequest* Arena::CreateMaybeMessage<::bugu::service::v1::ConfusionRequest>(Arena*);
template<> ::bugu::service::v1::DeleteArtifactMetadataReply* Arena::CreateMaybeMessage<::bugu::service::v1::DeleteArtifactMetadataReply>(Arena*);
template<> ::bugu::service::v1::DeleteArtifactMetadataRequest* Arena::CreateMaybeMessage<::bugu::service::v1::DeleteArtifactMetadataRequest>(Arena*);
template<> ::bugu::service::v1::DeleteFileMetadataReply* Arena::CreateMaybeMessage<::bugu::service::v1::DeleteFileMetadataReply>(Arena*);
template<> ::bugu::service::v1::DeleteFileMetadataRequest* Arena::CreateMaybeMessage<::bugu::service::v1::DeleteFileMetadataRequest>(Arena*);
template<> ::bugu::service::v1::DetectReply* Arena::CreateMaybeMessage<::bugu::service::v1::DetectReply>(Arena*);
template<> ::bugu::service::v1::DetectRequest* Arena::CreateMaybeMessage<::bugu::service::v1::DetectRequest>(Arena*);
template<> ::bugu::service::v1::GetArtifactMetadataByFileIdReply* Arena::CreateMaybeMessage<::bugu::service::v1::GetArtifactMetadataByFileIdReply>(Arena*);
template<> ::bugu::service::v1::GetArtifactMetadataByFileIdRequest* Arena::CreateMaybeMessage<::bugu::service::v1::GetArtifactMetadataByFileIdRequest>(Arena*);
template<> ::bugu::service::v1::GetArtifactMetadataReply* Arena::CreateMaybeMessage<::bugu::service::v1::GetArtifactMetadataReply>(Arena*);
template<> ::bugu::service::v1::GetArtifactMetadataRequest* Arena::CreateMaybeMessage<::bugu::service::v1::GetArtifactMetadataRequest>(Arena*);
template<> ::bugu::service::v1::GetCurrentUserReply* Arena::CreateMaybeMessage<::bugu::service::v1::GetCurrentUserReply>(Arena*);
template<> ::bugu::service::v1::GetCurrentUserRequest* Arena::CreateMaybeMessage<::bugu::service::v1::GetCurrentUserRequest>(Arena*);
template<> ::bugu::service::v1::GetFileMetaByUserIdReply* Arena::CreateMaybeMessage<::bugu::service::v1::GetFileMetaByUserIdReply>(Arena*);
template<> ::bugu::service::v1::GetFileMetaByUserIdRequest* Arena::CreateMaybeMessage<::bugu::service::v1::GetFileMetaByUserIdRequest>(Arena*);
template<> ::bugu::service::v1::GetFileMetaReply* Arena::CreateMaybeMessage<::bugu::service::v1::GetFileMetaReply>(Arena*);
template<> ::bugu::service::v1::GetFileMetaRequest* Arena::CreateMaybeMessage<::bugu::service::v1::GetFileMetaRequest>(Arena*);
template<> ::bugu::service::v1::LoginReply* Arena::CreateMaybeMessage<::bugu::service::v1::LoginReply>(Arena*);
template<> ::bugu::service::v1::LoginRequest* Arena::CreateMaybeMessage<::bugu::service::v1::LoginRequest>(Arena*);
template<> ::bugu::service::v1::LoginRequest_User* Arena::CreateMaybeMessage<::bugu::service::v1::LoginRequest_User>(Arena*);
template<> ::bugu::service::v1::RegisterReply* Arena::CreateMaybeMessage<::bugu::service::v1::RegisterReply>(Arena*);
template<> ::bugu::service::v1::RegisterRequest* Arena::CreateMaybeMessage<::bugu::service::v1::RegisterRequest>(Arena*);
template<> ::bugu::service::v1::RegisterRequest_User* Arena::CreateMaybeMessage<::bugu::service::v1::RegisterRequest_User>(Arena*);
template<> ::bugu::service::v1::UpdateUserReply* Arena::CreateMaybeMessage<::bugu::service::v1::UpdateUserReply>(Arena*);
template<> ::bugu::service::v1::UpdateUserRequest* Arena::CreateMaybeMessage<::bugu::service::v1::UpdateUserRequest>(Arena*);
template<> ::bugu::service::v1::UpdateUserRequest_User* Arena::CreateMaybeMessage<::bugu::service::v1::UpdateUserRequest_User>(Arena*);
template<> ::bugu::service::v1::UserStruct* Arena::CreateMaybeMessage<::bugu::service::v1::UserStruct>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bugu {
namespace service {
namespace v1 {

enum Type : int {
  TYPE_ADPOSHEL = 0,
  TYPE_AGENT = 1,
  TYPE_ALLAPLE = 2,
  TYPE_AMONETIZE = 3,
  TYPE_ANDROM = 4,
  TYPE_AUTORUN = 5,
  TYPE_BROWSE_FOX = 6,
  TYPE_DINWOD = 7,
  TYPE_ELEX = 8,
  TYPE_EXPIRO = 9,
  TYPE_FASONG = 10,
  TYPE_HACK_KMS = 11,
  TYPE_HLUX = 12,
  TYPE_INJECTOR = 13,
  TYPE_INSTALL_CORE = 14,
  TYPE_MULTI_Plug = 15,
  TYPE_NEOREKLAMI = 16,
  TYPE_NESHTA = 17,
  TYPE_OTHER = 18,
  TYPE_REGRUN = 19,
  TYPE_SALITY = 20,
  TYPE_SNARASITE = 21,
  TYPE_STABTINKO = 22,
  TYPE_VBA = 23,
  TYPE_VBKRYPT = 24,
  TYPE_VILSEL = 25,
  Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Type_IsValid(int value);
constexpr Type Type_MIN = TYPE_ADPOSHEL;
constexpr Type Type_MAX = TYPE_VILSEL;
constexpr int Type_ARRAYSIZE = Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Type_descriptor();
template<typename T>
inline const std::string& Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Type_descriptor(), enum_t_value);
}
inline bool Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Type>(
    Type_descriptor(), name, value);
}
// ===================================================================

class RegisterRequest_User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.RegisterRequest.User) */ {
 public:
  inline RegisterRequest_User() : RegisterRequest_User(nullptr) {}
  ~RegisterRequest_User() override;
  explicit constexpr RegisterRequest_User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterRequest_User(const RegisterRequest_User& from);
  RegisterRequest_User(RegisterRequest_User&& from) noexcept
    : RegisterRequest_User() {
    *this = ::std::move(from);
  }

  inline RegisterRequest_User& operator=(const RegisterRequest_User& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterRequest_User& operator=(RegisterRequest_User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterRequest_User& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterRequest_User* internal_default_instance() {
    return reinterpret_cast<const RegisterRequest_User*>(
               &_RegisterRequest_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RegisterRequest_User& a, RegisterRequest_User& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterRequest_User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterRequest_User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterRequest_User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterRequest_User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterRequest_User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegisterRequest_User& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterRequest_User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.RegisterRequest.User";
  }
  protected:
  explicit RegisterRequest_User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kEmailFieldNumber = 2,
    kPasswordFieldNumber = 3,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string email = 2;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string password = 3;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.RegisterRequest.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class RegisterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.RegisterRequest) */ {
 public:
  inline RegisterRequest() : RegisterRequest(nullptr) {}
  ~RegisterRequest() override;
  explicit constexpr RegisterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterRequest(const RegisterRequest& from);
  RegisterRequest(RegisterRequest&& from) noexcept
    : RegisterRequest() {
    *this = ::std::move(from);
  }

  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterRequest& operator=(RegisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterRequest*>(
               &_RegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RegisterRequest& a, RegisterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegisterRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.RegisterRequest";
  }
  protected:
  explicit RegisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RegisterRequest_User User;

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .bugu.service.v1.RegisterRequest.User user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::bugu::service::v1::RegisterRequest_User& user() const;
  PROTOBUF_NODISCARD ::bugu::service::v1::RegisterRequest_User* release_user();
  ::bugu::service::v1::RegisterRequest_User* mutable_user();
  void set_allocated_user(::bugu::service::v1::RegisterRequest_User* user);
  private:
  const ::bugu::service::v1::RegisterRequest_User& _internal_user() const;
  ::bugu::service::v1::RegisterRequest_User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::bugu::service::v1::RegisterRequest_User* user);
  ::bugu::service::v1::RegisterRequest_User* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:bugu.service.v1.RegisterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bugu::service::v1::RegisterRequest_User* user_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class RegisterReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.RegisterReply) */ {
 public:
  inline RegisterReply() : RegisterReply(nullptr) {}
  ~RegisterReply() override;
  explicit constexpr RegisterReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterReply(const RegisterReply& from);
  RegisterReply(RegisterReply&& from) noexcept
    : RegisterReply() {
    *this = ::std::move(from);
  }

  inline RegisterReply& operator=(const RegisterReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterReply& operator=(RegisterReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterReply* internal_default_instance() {
    return reinterpret_cast<const RegisterReply*>(
               &_RegisterReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RegisterReply& a, RegisterReply& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegisterReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.RegisterReply";
  }
  protected:
  explicit RegisterReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .bugu.service.v1.UserStruct user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::bugu::service::v1::UserStruct& user() const;
  PROTOBUF_NODISCARD ::bugu::service::v1::UserStruct* release_user();
  ::bugu::service::v1::UserStruct* mutable_user();
  void set_allocated_user(::bugu::service::v1::UserStruct* user);
  private:
  const ::bugu::service::v1::UserStruct& _internal_user() const;
  ::bugu::service::v1::UserStruct* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::bugu::service::v1::UserStruct* user);
  ::bugu::service::v1::UserStruct* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:bugu.service.v1.RegisterReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bugu::service::v1::UserStruct* user_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class LoginRequest_User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.LoginRequest.User) */ {
 public:
  inline LoginRequest_User() : LoginRequest_User(nullptr) {}
  ~LoginRequest_User() override;
  explicit constexpr LoginRequest_User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRequest_User(const LoginRequest_User& from);
  LoginRequest_User(LoginRequest_User&& from) noexcept
    : LoginRequest_User() {
    *this = ::std::move(from);
  }

  inline LoginRequest_User& operator=(const LoginRequest_User& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest_User& operator=(LoginRequest_User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest_User& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequest_User* internal_default_instance() {
    return reinterpret_cast<const LoginRequest_User*>(
               &_LoginRequest_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LoginRequest_User& a, LoginRequest_User& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequest_User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest_User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest_User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRequest_User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRequest_User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginRequest_User& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest_User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.LoginRequest.User";
  }
  protected:
  explicit LoginRequest_User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string email = 1;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.LoginRequest.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class LoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {}
  ~LoginRequest() override;
  explicit constexpr LoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRequest(const LoginRequest& from);
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.LoginRequest";
  }
  protected:
  explicit LoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LoginRequest_User User;

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .bugu.service.v1.LoginRequest.User user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::bugu::service::v1::LoginRequest_User& user() const;
  PROTOBUF_NODISCARD ::bugu::service::v1::LoginRequest_User* release_user();
  ::bugu::service::v1::LoginRequest_User* mutable_user();
  void set_allocated_user(::bugu::service::v1::LoginRequest_User* user);
  private:
  const ::bugu::service::v1::LoginRequest_User& _internal_user() const;
  ::bugu::service::v1::LoginRequest_User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::bugu::service::v1::LoginRequest_User* user);
  ::bugu::service::v1::LoginRequest_User* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:bugu.service.v1.LoginRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bugu::service::v1::LoginRequest_User* user_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class LoginReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.LoginReply) */ {
 public:
  inline LoginReply() : LoginReply(nullptr) {}
  ~LoginReply() override;
  explicit constexpr LoginReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginReply(const LoginReply& from);
  LoginReply(LoginReply&& from) noexcept
    : LoginReply() {
    *this = ::std::move(from);
  }

  inline LoginReply& operator=(const LoginReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginReply& operator=(LoginReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginReply* internal_default_instance() {
    return reinterpret_cast<const LoginReply*>(
               &_LoginReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LoginReply& a, LoginReply& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.LoginReply";
  }
  protected:
  explicit LoginReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 2,
    kUserFieldNumber = 1,
  };
  // string token = 2;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // .bugu.service.v1.UserStruct user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::bugu::service::v1::UserStruct& user() const;
  PROTOBUF_NODISCARD ::bugu::service::v1::UserStruct* release_user();
  ::bugu::service::v1::UserStruct* mutable_user();
  void set_allocated_user(::bugu::service::v1::UserStruct* user);
  private:
  const ::bugu::service::v1::UserStruct& _internal_user() const;
  ::bugu::service::v1::UserStruct* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::bugu::service::v1::UserStruct* user);
  ::bugu::service::v1::UserStruct* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:bugu.service.v1.LoginReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::bugu::service::v1::UserStruct* user_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class GetCurrentUserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.GetCurrentUserRequest) */ {
 public:
  inline GetCurrentUserRequest() : GetCurrentUserRequest(nullptr) {}
  ~GetCurrentUserRequest() override;
  explicit constexpr GetCurrentUserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCurrentUserRequest(const GetCurrentUserRequest& from);
  GetCurrentUserRequest(GetCurrentUserRequest&& from) noexcept
    : GetCurrentUserRequest() {
    *this = ::std::move(from);
  }

  inline GetCurrentUserRequest& operator=(const GetCurrentUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCurrentUserRequest& operator=(GetCurrentUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCurrentUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCurrentUserRequest* internal_default_instance() {
    return reinterpret_cast<const GetCurrentUserRequest*>(
               &_GetCurrentUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetCurrentUserRequest& a, GetCurrentUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCurrentUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCurrentUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCurrentUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetCurrentUserRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetCurrentUserRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetCurrentUserRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCurrentUserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.GetCurrentUserRequest";
  }
  protected:
  explicit GetCurrentUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [(.validate.rules) = {
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.GetCurrentUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class GetCurrentUserReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.GetCurrentUserReply) */ {
 public:
  inline GetCurrentUserReply() : GetCurrentUserReply(nullptr) {}
  ~GetCurrentUserReply() override;
  explicit constexpr GetCurrentUserReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCurrentUserReply(const GetCurrentUserReply& from);
  GetCurrentUserReply(GetCurrentUserReply&& from) noexcept
    : GetCurrentUserReply() {
    *this = ::std::move(from);
  }

  inline GetCurrentUserReply& operator=(const GetCurrentUserReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCurrentUserReply& operator=(GetCurrentUserReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCurrentUserReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCurrentUserReply* internal_default_instance() {
    return reinterpret_cast<const GetCurrentUserReply*>(
               &_GetCurrentUserReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetCurrentUserReply& a, GetCurrentUserReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCurrentUserReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCurrentUserReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCurrentUserReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetCurrentUserReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetCurrentUserReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetCurrentUserReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCurrentUserReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.GetCurrentUserReply";
  }
  protected:
  explicit GetCurrentUserReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .bugu.service.v1.UserStruct user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::bugu::service::v1::UserStruct& user() const;
  PROTOBUF_NODISCARD ::bugu::service::v1::UserStruct* release_user();
  ::bugu::service::v1::UserStruct* mutable_user();
  void set_allocated_user(::bugu::service::v1::UserStruct* user);
  private:
  const ::bugu::service::v1::UserStruct& _internal_user() const;
  ::bugu::service::v1::UserStruct* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::bugu::service::v1::UserStruct* user);
  ::bugu::service::v1::UserStruct* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:bugu.service.v1.GetCurrentUserReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bugu::service::v1::UserStruct* user_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class UpdateUserRequest_User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.UpdateUserRequest.User) */ {
 public:
  inline UpdateUserRequest_User() : UpdateUserRequest_User(nullptr) {}
  ~UpdateUserRequest_User() override;
  explicit constexpr UpdateUserRequest_User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateUserRequest_User(const UpdateUserRequest_User& from);
  UpdateUserRequest_User(UpdateUserRequest_User&& from) noexcept
    : UpdateUserRequest_User() {
    *this = ::std::move(from);
  }

  inline UpdateUserRequest_User& operator=(const UpdateUserRequest_User& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateUserRequest_User& operator=(UpdateUserRequest_User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateUserRequest_User& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateUserRequest_User* internal_default_instance() {
    return reinterpret_cast<const UpdateUserRequest_User*>(
               &_UpdateUserRequest_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UpdateUserRequest_User& a, UpdateUserRequest_User& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateUserRequest_User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateUserRequest_User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateUserRequest_User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateUserRequest_User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateUserRequest_User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateUserRequest_User& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateUserRequest_User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.UpdateUserRequest.User";
  }
  protected:
  explicit UpdateUserRequest_User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kEmailFieldNumber = 2,
    kUsernameFieldNumber = 4,
    kPasswordFieldNumber = 5,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string email = 2;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string username = 4;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 5;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.UpdateUserRequest.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class UpdateUserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.UpdateUserRequest) */ {
 public:
  inline UpdateUserRequest() : UpdateUserRequest(nullptr) {}
  ~UpdateUserRequest() override;
  explicit constexpr UpdateUserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateUserRequest(const UpdateUserRequest& from);
  UpdateUserRequest(UpdateUserRequest&& from) noexcept
    : UpdateUserRequest() {
    *this = ::std::move(from);
  }

  inline UpdateUserRequest& operator=(const UpdateUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateUserRequest& operator=(UpdateUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateUserRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateUserRequest*>(
               &_UpdateUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UpdateUserRequest& a, UpdateUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateUserRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateUserRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateUserRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateUserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.UpdateUserRequest";
  }
  protected:
  explicit UpdateUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UpdateUserRequest_User User;

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .bugu.service.v1.UpdateUserRequest.User user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::bugu::service::v1::UpdateUserRequest_User& user() const;
  PROTOBUF_NODISCARD ::bugu::service::v1::UpdateUserRequest_User* release_user();
  ::bugu::service::v1::UpdateUserRequest_User* mutable_user();
  void set_allocated_user(::bugu::service::v1::UpdateUserRequest_User* user);
  private:
  const ::bugu::service::v1::UpdateUserRequest_User& _internal_user() const;
  ::bugu::service::v1::UpdateUserRequest_User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::bugu::service::v1::UpdateUserRequest_User* user);
  ::bugu::service::v1::UpdateUserRequest_User* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:bugu.service.v1.UpdateUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bugu::service::v1::UpdateUserRequest_User* user_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class UpdateUserReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.UpdateUserReply) */ {
 public:
  inline UpdateUserReply() : UpdateUserReply(nullptr) {}
  ~UpdateUserReply() override;
  explicit constexpr UpdateUserReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateUserReply(const UpdateUserReply& from);
  UpdateUserReply(UpdateUserReply&& from) noexcept
    : UpdateUserReply() {
    *this = ::std::move(from);
  }

  inline UpdateUserReply& operator=(const UpdateUserReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateUserReply& operator=(UpdateUserReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateUserReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateUserReply* internal_default_instance() {
    return reinterpret_cast<const UpdateUserReply*>(
               &_UpdateUserReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(UpdateUserReply& a, UpdateUserReply& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateUserReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateUserReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateUserReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateUserReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateUserReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateUserReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateUserReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.UpdateUserReply";
  }
  protected:
  explicit UpdateUserReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .bugu.service.v1.UserStruct user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::bugu::service::v1::UserStruct& user() const;
  PROTOBUF_NODISCARD ::bugu::service::v1::UserStruct* release_user();
  ::bugu::service::v1::UserStruct* mutable_user();
  void set_allocated_user(::bugu::service::v1::UserStruct* user);
  private:
  const ::bugu::service::v1::UserStruct& _internal_user() const;
  ::bugu::service::v1::UserStruct* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::bugu::service::v1::UserStruct* user);
  ::bugu::service::v1::UserStruct* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:bugu.service.v1.UpdateUserReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bugu::service::v1::UserStruct* user_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class UserStruct final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.UserStruct) */ {
 public:
  inline UserStruct() : UserStruct(nullptr) {}
  ~UserStruct() override;
  explicit constexpr UserStruct(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserStruct(const UserStruct& from);
  UserStruct(UserStruct&& from) noexcept
    : UserStruct() {
    *this = ::std::move(from);
  }

  inline UserStruct& operator=(const UserStruct& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserStruct& operator=(UserStruct&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserStruct& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserStruct* internal_default_instance() {
    return reinterpret_cast<const UserStruct*>(
               &_UserStruct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UserStruct& a, UserStruct& b) {
    a.Swap(&b);
  }
  inline void Swap(UserStruct* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserStruct* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserStruct* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserStruct>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserStruct& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserStruct& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserStruct* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.UserStruct";
  }
  protected:
  explicit UserStruct(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kEmailFieldNumber = 2,
    kUsernameFieldNumber = 3,
  };
  // string id = 1 [(.validate.rules) = {
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string email = 2;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string username = 3;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.UserStruct)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class GetFileMetaRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.GetFileMetaRequest) */ {
 public:
  inline GetFileMetaRequest() : GetFileMetaRequest(nullptr) {}
  ~GetFileMetaRequest() override;
  explicit constexpr GetFileMetaRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFileMetaRequest(const GetFileMetaRequest& from);
  GetFileMetaRequest(GetFileMetaRequest&& from) noexcept
    : GetFileMetaRequest() {
    *this = ::std::move(from);
  }

  inline GetFileMetaRequest& operator=(const GetFileMetaRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFileMetaRequest& operator=(GetFileMetaRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFileMetaRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFileMetaRequest* internal_default_instance() {
    return reinterpret_cast<const GetFileMetaRequest*>(
               &_GetFileMetaRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetFileMetaRequest& a, GetFileMetaRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFileMetaRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFileMetaRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFileMetaRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFileMetaRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFileMetaRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFileMetaRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFileMetaRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.GetFileMetaRequest";
  }
  protected:
  explicit GetFileMetaRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kFileIdFieldNumber = 2,
  };
  // string user_id = 1 [(.validate.rules) = {
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string file_id = 2 [(.validate.rules) = {
  void clear_file_id();
  const std::string& file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_id();
  PROTOBUF_NODISCARD std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.GetFileMetaRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class GetFileMetaReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.GetFileMetaReply) */ {
 public:
  inline GetFileMetaReply() : GetFileMetaReply(nullptr) {}
  ~GetFileMetaReply() override;
  explicit constexpr GetFileMetaReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFileMetaReply(const GetFileMetaReply& from);
  GetFileMetaReply(GetFileMetaReply&& from) noexcept
    : GetFileMetaReply() {
    *this = ::std::move(from);
  }

  inline GetFileMetaReply& operator=(const GetFileMetaReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFileMetaReply& operator=(GetFileMetaReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFileMetaReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFileMetaReply* internal_default_instance() {
    return reinterpret_cast<const GetFileMetaReply*>(
               &_GetFileMetaReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetFileMetaReply& a, GetFileMetaReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFileMetaReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFileMetaReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFileMetaReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFileMetaReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFileMetaReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFileMetaReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFileMetaReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.GetFileMetaReply";
  }
  protected:
  explicit GetFileMetaReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileIdFieldNumber = 1,
    kFileSha1FieldNumber = 2,
    kFileAddrFieldNumber = 4,
    kFileSizeFieldNumber = 3,
    kTypeFieldNumber = 5,
  };
  // string file_id = 1 [(.validate.rules) = {
  void clear_file_id();
  const std::string& file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_id();
  PROTOBUF_NODISCARD std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // string file_sha_1 = 2;
  void clear_file_sha_1();
  const std::string& file_sha_1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_sha_1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_sha_1();
  PROTOBUF_NODISCARD std::string* release_file_sha_1();
  void set_allocated_file_sha_1(std::string* file_sha_1);
  private:
  const std::string& _internal_file_sha_1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_sha_1(const std::string& value);
  std::string* _internal_mutable_file_sha_1();
  public:

  // string file_addr = 4;
  void clear_file_addr();
  const std::string& file_addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_addr();
  PROTOBUF_NODISCARD std::string* release_file_addr();
  void set_allocated_file_addr(std::string* file_addr);
  private:
  const std::string& _internal_file_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_addr(const std::string& value);
  std::string* _internal_mutable_file_addr();
  public:

  // int64 file_size = 3;
  void clear_file_size();
  int64_t file_size() const;
  void set_file_size(int64_t value);
  private:
  int64_t _internal_file_size() const;
  void _internal_set_file_size(int64_t value);
  public:

  // .bugu.service.v1.Type type = 5;
  void clear_type();
  ::bugu::service::v1::Type type() const;
  void set_type(::bugu::service::v1::Type value);
  private:
  ::bugu::service::v1::Type _internal_type() const;
  void _internal_set_type(::bugu::service::v1::Type value);
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.GetFileMetaReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_sha_1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_addr_;
  int64_t file_size_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class GetFileMetaByUserIdRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.GetFileMetaByUserIdRequest) */ {
 public:
  inline GetFileMetaByUserIdRequest() : GetFileMetaByUserIdRequest(nullptr) {}
  ~GetFileMetaByUserIdRequest() override;
  explicit constexpr GetFileMetaByUserIdRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFileMetaByUserIdRequest(const GetFileMetaByUserIdRequest& from);
  GetFileMetaByUserIdRequest(GetFileMetaByUserIdRequest&& from) noexcept
    : GetFileMetaByUserIdRequest() {
    *this = ::std::move(from);
  }

  inline GetFileMetaByUserIdRequest& operator=(const GetFileMetaByUserIdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFileMetaByUserIdRequest& operator=(GetFileMetaByUserIdRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFileMetaByUserIdRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFileMetaByUserIdRequest* internal_default_instance() {
    return reinterpret_cast<const GetFileMetaByUserIdRequest*>(
               &_GetFileMetaByUserIdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetFileMetaByUserIdRequest& a, GetFileMetaByUserIdRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFileMetaByUserIdRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFileMetaByUserIdRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFileMetaByUserIdRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFileMetaByUserIdRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFileMetaByUserIdRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFileMetaByUserIdRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFileMetaByUserIdRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.GetFileMetaByUserIdRequest";
  }
  protected:
  explicit GetFileMetaByUserIdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // string user_id = 1 [(.validate.rules) = {
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.GetFileMetaByUserIdRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class GetFileMetaByUserIdReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.GetFileMetaByUserIdReply) */ {
 public:
  inline GetFileMetaByUserIdReply() : GetFileMetaByUserIdReply(nullptr) {}
  ~GetFileMetaByUserIdReply() override;
  explicit constexpr GetFileMetaByUserIdReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFileMetaByUserIdReply(const GetFileMetaByUserIdReply& from);
  GetFileMetaByUserIdReply(GetFileMetaByUserIdReply&& from) noexcept
    : GetFileMetaByUserIdReply() {
    *this = ::std::move(from);
  }

  inline GetFileMetaByUserIdReply& operator=(const GetFileMetaByUserIdReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFileMetaByUserIdReply& operator=(GetFileMetaByUserIdReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFileMetaByUserIdReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFileMetaByUserIdReply* internal_default_instance() {
    return reinterpret_cast<const GetFileMetaByUserIdReply*>(
               &_GetFileMetaByUserIdReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetFileMetaByUserIdReply& a, GetFileMetaByUserIdReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFileMetaByUserIdReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFileMetaByUserIdReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFileMetaByUserIdReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFileMetaByUserIdReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFileMetaByUserIdReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFileMetaByUserIdReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFileMetaByUserIdReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.GetFileMetaByUserIdReply";
  }
  protected:
  explicit GetFileMetaByUserIdReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileMetadataFieldNumber = 1,
  };
  // repeated .bugu.service.v1.GetFileMetaReply file_metadata = 1;
  int file_metadata_size() const;
  private:
  int _internal_file_metadata_size() const;
  public:
  void clear_file_metadata();
  ::bugu::service::v1::GetFileMetaReply* mutable_file_metadata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bugu::service::v1::GetFileMetaReply >*
      mutable_file_metadata();
  private:
  const ::bugu::service::v1::GetFileMetaReply& _internal_file_metadata(int index) const;
  ::bugu::service::v1::GetFileMetaReply* _internal_add_file_metadata();
  public:
  const ::bugu::service::v1::GetFileMetaReply& file_metadata(int index) const;
  ::bugu::service::v1::GetFileMetaReply* add_file_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bugu::service::v1::GetFileMetaReply >&
      file_metadata() const;

  // @@protoc_insertion_point(class_scope:bugu.service.v1.GetFileMetaByUserIdReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bugu::service::v1::GetFileMetaReply > file_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class DeleteFileMetadataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.DeleteFileMetadataRequest) */ {
 public:
  inline DeleteFileMetadataRequest() : DeleteFileMetadataRequest(nullptr) {}
  ~DeleteFileMetadataRequest() override;
  explicit constexpr DeleteFileMetadataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteFileMetadataRequest(const DeleteFileMetadataRequest& from);
  DeleteFileMetadataRequest(DeleteFileMetadataRequest&& from) noexcept
    : DeleteFileMetadataRequest() {
    *this = ::std::move(from);
  }

  inline DeleteFileMetadataRequest& operator=(const DeleteFileMetadataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteFileMetadataRequest& operator=(DeleteFileMetadataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteFileMetadataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteFileMetadataRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteFileMetadataRequest*>(
               &_DeleteFileMetadataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(DeleteFileMetadataRequest& a, DeleteFileMetadataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteFileMetadataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteFileMetadataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteFileMetadataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteFileMetadataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteFileMetadataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteFileMetadataRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteFileMetadataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.DeleteFileMetadataRequest";
  }
  protected:
  explicit DeleteFileMetadataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kFileIdFieldNumber = 2,
  };
  // string user_id = 1 [(.validate.rules) = {
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string file_id = 2 [(.validate.rules) = {
  void clear_file_id();
  const std::string& file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_id();
  PROTOBUF_NODISCARD std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.DeleteFileMetadataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class DeleteFileMetadataReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bugu.service.v1.DeleteFileMetadataReply) */ {
 public:
  inline DeleteFileMetadataReply() : DeleteFileMetadataReply(nullptr) {}
  explicit constexpr DeleteFileMetadataReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteFileMetadataReply(const DeleteFileMetadataReply& from);
  DeleteFileMetadataReply(DeleteFileMetadataReply&& from) noexcept
    : DeleteFileMetadataReply() {
    *this = ::std::move(from);
  }

  inline DeleteFileMetadataReply& operator=(const DeleteFileMetadataReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteFileMetadataReply& operator=(DeleteFileMetadataReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteFileMetadataReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteFileMetadataReply* internal_default_instance() {
    return reinterpret_cast<const DeleteFileMetadataReply*>(
               &_DeleteFileMetadataReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(DeleteFileMetadataReply& a, DeleteFileMetadataReply& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteFileMetadataReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteFileMetadataReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteFileMetadataReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteFileMetadataReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteFileMetadataReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteFileMetadataReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.DeleteFileMetadataReply";
  }
  protected:
  explicit DeleteFileMetadataReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bugu.service.v1.DeleteFileMetadataReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class DetectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.DetectRequest) */ {
 public:
  inline DetectRequest() : DetectRequest(nullptr) {}
  ~DetectRequest() override;
  explicit constexpr DetectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DetectRequest(const DetectRequest& from);
  DetectRequest(DetectRequest&& from) noexcept
    : DetectRequest() {
    *this = ::std::move(from);
  }

  inline DetectRequest& operator=(const DetectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetectRequest& operator=(DetectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DetectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DetectRequest* internal_default_instance() {
    return reinterpret_cast<const DetectRequest*>(
               &_DetectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(DetectRequest& a, DetectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DetectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DetectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DetectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DetectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DetectRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetectRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.DetectRequest";
  }
  protected:
  explicit DetectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kFileIdFieldNumber = 2,
  };
  // string user_id = 1 [(.validate.rules) = {
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string file_id = 2 [(.validate.rules) = {
  void clear_file_id();
  const std::string& file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_id();
  PROTOBUF_NODISCARD std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.DetectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class DetectReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.DetectReply) */ {
 public:
  inline DetectReply() : DetectReply(nullptr) {}
  ~DetectReply() override;
  explicit constexpr DetectReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DetectReply(const DetectReply& from);
  DetectReply(DetectReply&& from) noexcept
    : DetectReply() {
    *this = ::std::move(from);
  }

  inline DetectReply& operator=(const DetectReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetectReply& operator=(DetectReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DetectReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const DetectReply* internal_default_instance() {
    return reinterpret_cast<const DetectReply*>(
               &_DetectReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(DetectReply& a, DetectReply& b) {
    a.Swap(&b);
  }
  inline void Swap(DetectReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetectReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DetectReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DetectReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DetectReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DetectReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetectReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.DetectReply";
  }
  protected:
  explicit DetectReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArtifactIdFieldNumber = 1,
  };
  // string artifact_id = 1 [(.validate.rules) = {
  void clear_artifact_id();
  const std::string& artifact_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_artifact_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_artifact_id();
  PROTOBUF_NODISCARD std::string* release_artifact_id();
  void set_allocated_artifact_id(std::string* artifact_id);
  private:
  const std::string& _internal_artifact_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_artifact_id(const std::string& value);
  std::string* _internal_mutable_artifact_id();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.DetectReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr artifact_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class ConfusionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.ConfusionRequest) */ {
 public:
  inline ConfusionRequest() : ConfusionRequest(nullptr) {}
  ~ConfusionRequest() override;
  explicit constexpr ConfusionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfusionRequest(const ConfusionRequest& from);
  ConfusionRequest(ConfusionRequest&& from) noexcept
    : ConfusionRequest() {
    *this = ::std::move(from);
  }

  inline ConfusionRequest& operator=(const ConfusionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfusionRequest& operator=(ConfusionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfusionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfusionRequest* internal_default_instance() {
    return reinterpret_cast<const ConfusionRequest*>(
               &_ConfusionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ConfusionRequest& a, ConfusionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfusionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfusionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfusionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfusionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfusionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfusionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfusionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.ConfusionRequest";
  }
  protected:
  explicit ConfusionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kFileIdFieldNumber = 2,
  };
  // string user_id = 1 [(.validate.rules) = {
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string file_id = 2 [(.validate.rules) = {
  void clear_file_id();
  const std::string& file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_id();
  PROTOBUF_NODISCARD std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.ConfusionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class ConfusionReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.ConfusionReply) */ {
 public:
  inline ConfusionReply() : ConfusionReply(nullptr) {}
  ~ConfusionReply() override;
  explicit constexpr ConfusionReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfusionReply(const ConfusionReply& from);
  ConfusionReply(ConfusionReply&& from) noexcept
    : ConfusionReply() {
    *this = ::std::move(from);
  }

  inline ConfusionReply& operator=(const ConfusionReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfusionReply& operator=(ConfusionReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfusionReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfusionReply* internal_default_instance() {
    return reinterpret_cast<const ConfusionReply*>(
               &_ConfusionReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ConfusionReply& a, ConfusionReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfusionReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfusionReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfusionReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfusionReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfusionReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfusionReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfusionReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.ConfusionReply";
  }
  protected:
  explicit ConfusionReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArtifactIdFieldNumber = 1,
    kFileIdFieldNumber = 2,
    kAffiliatedFileIdFieldNumber = 3,
    kMethodFieldNumber = 4,
  };
  // string artifact_id = 1 [(.validate.rules) = {
  void clear_artifact_id();
  const std::string& artifact_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_artifact_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_artifact_id();
  PROTOBUF_NODISCARD std::string* release_artifact_id();
  void set_allocated_artifact_id(std::string* artifact_id);
  private:
  const std::string& _internal_artifact_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_artifact_id(const std::string& value);
  std::string* _internal_mutable_artifact_id();
  public:

  // string file_id = 2 [(.validate.rules) = {
  void clear_file_id();
  const std::string& file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_id();
  PROTOBUF_NODISCARD std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // string affiliated_file_id = 3 [(.validate.rules) = {
  void clear_affiliated_file_id();
  const std::string& affiliated_file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_affiliated_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_affiliated_file_id();
  PROTOBUF_NODISCARD std::string* release_affiliated_file_id();
  void set_allocated_affiliated_file_id(std::string* affiliated_file_id);
  private:
  const std::string& _internal_affiliated_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_affiliated_file_id(const std::string& value);
  std::string* _internal_mutable_affiliated_file_id();
  public:

  // string method = 4;
  void clear_method();
  const std::string& method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method();
  PROTOBUF_NODISCARD std::string* release_method();
  void set_allocated_method(std::string* method);
  private:
  const std::string& _internal_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.ConfusionReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr artifact_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr affiliated_file_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class GetArtifactMetadataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.GetArtifactMetadataRequest) */ {
 public:
  inline GetArtifactMetadataRequest() : GetArtifactMetadataRequest(nullptr) {}
  ~GetArtifactMetadataRequest() override;
  explicit constexpr GetArtifactMetadataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetArtifactMetadataRequest(const GetArtifactMetadataRequest& from);
  GetArtifactMetadataRequest(GetArtifactMetadataRequest&& from) noexcept
    : GetArtifactMetadataRequest() {
    *this = ::std::move(from);
  }

  inline GetArtifactMetadataRequest& operator=(const GetArtifactMetadataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetArtifactMetadataRequest& operator=(GetArtifactMetadataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetArtifactMetadataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetArtifactMetadataRequest* internal_default_instance() {
    return reinterpret_cast<const GetArtifactMetadataRequest*>(
               &_GetArtifactMetadataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(GetArtifactMetadataRequest& a, GetArtifactMetadataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetArtifactMetadataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetArtifactMetadataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetArtifactMetadataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetArtifactMetadataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetArtifactMetadataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetArtifactMetadataRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetArtifactMetadataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.GetArtifactMetadataRequest";
  }
  protected:
  explicit GetArtifactMetadataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kArtifactIdFieldNumber = 2,
  };
  // string user_id = 1 [(.validate.rules) = {
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string artifact_id = 2 [(.validate.rules) = {
  void clear_artifact_id();
  const std::string& artifact_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_artifact_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_artifact_id();
  PROTOBUF_NODISCARD std::string* release_artifact_id();
  void set_allocated_artifact_id(std::string* artifact_id);
  private:
  const std::string& _internal_artifact_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_artifact_id(const std::string& value);
  std::string* _internal_mutable_artifact_id();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.GetArtifactMetadataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr artifact_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class GetArtifactMetadataReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.GetArtifactMetadataReply) */ {
 public:
  inline GetArtifactMetadataReply() : GetArtifactMetadataReply(nullptr) {}
  ~GetArtifactMetadataReply() override;
  explicit constexpr GetArtifactMetadataReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetArtifactMetadataReply(const GetArtifactMetadataReply& from);
  GetArtifactMetadataReply(GetArtifactMetadataReply&& from) noexcept
    : GetArtifactMetadataReply() {
    *this = ::std::move(from);
  }

  inline GetArtifactMetadataReply& operator=(const GetArtifactMetadataReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetArtifactMetadataReply& operator=(GetArtifactMetadataReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetArtifactMetadataReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetArtifactMetadataReply* internal_default_instance() {
    return reinterpret_cast<const GetArtifactMetadataReply*>(
               &_GetArtifactMetadataReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(GetArtifactMetadataReply& a, GetArtifactMetadataReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetArtifactMetadataReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetArtifactMetadataReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetArtifactMetadataReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetArtifactMetadataReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetArtifactMetadataReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetArtifactMetadataReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetArtifactMetadataReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.GetArtifactMetadataReply";
  }
  protected:
  explicit GetArtifactMetadataReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArtifactIdFieldNumber = 1,
    kFileIdFieldNumber = 2,
    kAffiliatedFileIdFieldNumber = 3,
    kMethodFieldNumber = 4,
  };
  // string artifact_id = 1 [(.validate.rules) = {
  void clear_artifact_id();
  const std::string& artifact_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_artifact_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_artifact_id();
  PROTOBUF_NODISCARD std::string* release_artifact_id();
  void set_allocated_artifact_id(std::string* artifact_id);
  private:
  const std::string& _internal_artifact_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_artifact_id(const std::string& value);
  std::string* _internal_mutable_artifact_id();
  public:

  // string file_id = 2 [(.validate.rules) = {
  void clear_file_id();
  const std::string& file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_id();
  PROTOBUF_NODISCARD std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // string affiliated_file_id = 3 [(.validate.rules) = {
  void clear_affiliated_file_id();
  const std::string& affiliated_file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_affiliated_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_affiliated_file_id();
  PROTOBUF_NODISCARD std::string* release_affiliated_file_id();
  void set_allocated_affiliated_file_id(std::string* affiliated_file_id);
  private:
  const std::string& _internal_affiliated_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_affiliated_file_id(const std::string& value);
  std::string* _internal_mutable_affiliated_file_id();
  public:

  // string method = 4;
  void clear_method();
  const std::string& method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method();
  PROTOBUF_NODISCARD std::string* release_method();
  void set_allocated_method(std::string* method);
  private:
  const std::string& _internal_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.GetArtifactMetadataReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr artifact_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr affiliated_file_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class GetArtifactMetadataByFileIdRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.GetArtifactMetadataByFileIdRequest) */ {
 public:
  inline GetArtifactMetadataByFileIdRequest() : GetArtifactMetadataByFileIdRequest(nullptr) {}
  ~GetArtifactMetadataByFileIdRequest() override;
  explicit constexpr GetArtifactMetadataByFileIdRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetArtifactMetadataByFileIdRequest(const GetArtifactMetadataByFileIdRequest& from);
  GetArtifactMetadataByFileIdRequest(GetArtifactMetadataByFileIdRequest&& from) noexcept
    : GetArtifactMetadataByFileIdRequest() {
    *this = ::std::move(from);
  }

  inline GetArtifactMetadataByFileIdRequest& operator=(const GetArtifactMetadataByFileIdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetArtifactMetadataByFileIdRequest& operator=(GetArtifactMetadataByFileIdRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetArtifactMetadataByFileIdRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetArtifactMetadataByFileIdRequest* internal_default_instance() {
    return reinterpret_cast<const GetArtifactMetadataByFileIdRequest*>(
               &_GetArtifactMetadataByFileIdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(GetArtifactMetadataByFileIdRequest& a, GetArtifactMetadataByFileIdRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetArtifactMetadataByFileIdRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetArtifactMetadataByFileIdRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetArtifactMetadataByFileIdRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetArtifactMetadataByFileIdRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetArtifactMetadataByFileIdRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetArtifactMetadataByFileIdRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetArtifactMetadataByFileIdRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.GetArtifactMetadataByFileIdRequest";
  }
  protected:
  explicit GetArtifactMetadataByFileIdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kFileIdFieldNumber = 2,
  };
  // string user_id = 1 [(.validate.rules) = {
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string file_id = 2 [(.validate.rules) = {
  void clear_file_id();
  const std::string& file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_id();
  PROTOBUF_NODISCARD std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.GetArtifactMetadataByFileIdRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class GetArtifactMetadataByFileIdReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.GetArtifactMetadataByFileIdReply) */ {
 public:
  inline GetArtifactMetadataByFileIdReply() : GetArtifactMetadataByFileIdReply(nullptr) {}
  ~GetArtifactMetadataByFileIdReply() override;
  explicit constexpr GetArtifactMetadataByFileIdReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetArtifactMetadataByFileIdReply(const GetArtifactMetadataByFileIdReply& from);
  GetArtifactMetadataByFileIdReply(GetArtifactMetadataByFileIdReply&& from) noexcept
    : GetArtifactMetadataByFileIdReply() {
    *this = ::std::move(from);
  }

  inline GetArtifactMetadataByFileIdReply& operator=(const GetArtifactMetadataByFileIdReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetArtifactMetadataByFileIdReply& operator=(GetArtifactMetadataByFileIdReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetArtifactMetadataByFileIdReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetArtifactMetadataByFileIdReply* internal_default_instance() {
    return reinterpret_cast<const GetArtifactMetadataByFileIdReply*>(
               &_GetArtifactMetadataByFileIdReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(GetArtifactMetadataByFileIdReply& a, GetArtifactMetadataByFileIdReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetArtifactMetadataByFileIdReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetArtifactMetadataByFileIdReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetArtifactMetadataByFileIdReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetArtifactMetadataByFileIdReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetArtifactMetadataByFileIdReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetArtifactMetadataByFileIdReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetArtifactMetadataByFileIdReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.GetArtifactMetadataByFileIdReply";
  }
  protected:
  explicit GetArtifactMetadataByFileIdReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArtifactMetadataFieldNumber = 1,
  };
  // repeated .bugu.service.v1.GetArtifactMetadataReply artifact_metadata = 1;
  int artifact_metadata_size() const;
  private:
  int _internal_artifact_metadata_size() const;
  public:
  void clear_artifact_metadata();
  ::bugu::service::v1::GetArtifactMetadataReply* mutable_artifact_metadata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bugu::service::v1::GetArtifactMetadataReply >*
      mutable_artifact_metadata();
  private:
  const ::bugu::service::v1::GetArtifactMetadataReply& _internal_artifact_metadata(int index) const;
  ::bugu::service::v1::GetArtifactMetadataReply* _internal_add_artifact_metadata();
  public:
  const ::bugu::service::v1::GetArtifactMetadataReply& artifact_metadata(int index) const;
  ::bugu::service::v1::GetArtifactMetadataReply* add_artifact_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bugu::service::v1::GetArtifactMetadataReply >&
      artifact_metadata() const;

  // @@protoc_insertion_point(class_scope:bugu.service.v1.GetArtifactMetadataByFileIdReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bugu::service::v1::GetArtifactMetadataReply > artifact_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class DeleteArtifactMetadataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bugu.service.v1.DeleteArtifactMetadataRequest) */ {
 public:
  inline DeleteArtifactMetadataRequest() : DeleteArtifactMetadataRequest(nullptr) {}
  ~DeleteArtifactMetadataRequest() override;
  explicit constexpr DeleteArtifactMetadataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteArtifactMetadataRequest(const DeleteArtifactMetadataRequest& from);
  DeleteArtifactMetadataRequest(DeleteArtifactMetadataRequest&& from) noexcept
    : DeleteArtifactMetadataRequest() {
    *this = ::std::move(from);
  }

  inline DeleteArtifactMetadataRequest& operator=(const DeleteArtifactMetadataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteArtifactMetadataRequest& operator=(DeleteArtifactMetadataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteArtifactMetadataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteArtifactMetadataRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteArtifactMetadataRequest*>(
               &_DeleteArtifactMetadataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(DeleteArtifactMetadataRequest& a, DeleteArtifactMetadataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteArtifactMetadataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteArtifactMetadataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteArtifactMetadataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteArtifactMetadataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteArtifactMetadataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteArtifactMetadataRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteArtifactMetadataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.DeleteArtifactMetadataRequest";
  }
  protected:
  explicit DeleteArtifactMetadataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kArtifactIdFieldNumber = 2,
  };
  // string user_id = 1 [(.validate.rules) = {
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string artifact_id = 2 [(.validate.rules) = {
  void clear_artifact_id();
  const std::string& artifact_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_artifact_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_artifact_id();
  PROTOBUF_NODISCARD std::string* release_artifact_id();
  void set_allocated_artifact_id(std::string* artifact_id);
  private:
  const std::string& _internal_artifact_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_artifact_id(const std::string& value);
  std::string* _internal_mutable_artifact_id();
  public:

  // @@protoc_insertion_point(class_scope:bugu.service.v1.DeleteArtifactMetadataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr artifact_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// -------------------------------------------------------------------

class DeleteArtifactMetadataReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:bugu.service.v1.DeleteArtifactMetadataReply) */ {
 public:
  inline DeleteArtifactMetadataReply() : DeleteArtifactMetadataReply(nullptr) {}
  explicit constexpr DeleteArtifactMetadataReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteArtifactMetadataReply(const DeleteArtifactMetadataReply& from);
  DeleteArtifactMetadataReply(DeleteArtifactMetadataReply&& from) noexcept
    : DeleteArtifactMetadataReply() {
    *this = ::std::move(from);
  }

  inline DeleteArtifactMetadataReply& operator=(const DeleteArtifactMetadataReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteArtifactMetadataReply& operator=(DeleteArtifactMetadataReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteArtifactMetadataReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteArtifactMetadataReply* internal_default_instance() {
    return reinterpret_cast<const DeleteArtifactMetadataReply*>(
               &_DeleteArtifactMetadataReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(DeleteArtifactMetadataReply& a, DeleteArtifactMetadataReply& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteArtifactMetadataReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteArtifactMetadataReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteArtifactMetadataReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteArtifactMetadataReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteArtifactMetadataReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteArtifactMetadataReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bugu.service.v1.DeleteArtifactMetadataReply";
  }
  protected:
  explicit DeleteArtifactMetadataReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bugu.service.v1.DeleteArtifactMetadataReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bugu_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RegisterRequest_User

// string username = 1;
inline void RegisterRequest_User::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& RegisterRequest_User::username() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.RegisterRequest.User.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterRequest_User::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.RegisterRequest.User.username)
}
inline std::string* RegisterRequest_User::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.RegisterRequest.User.username)
  return _s;
}
inline const std::string& RegisterRequest_User::_internal_username() const {
  return username_.Get();
}
inline void RegisterRequest_User::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegisterRequest_User::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegisterRequest_User::release_username() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.RegisterRequest.User.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegisterRequest_User::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.RegisterRequest.User.username)
}

// string email = 2;
inline void RegisterRequest_User::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& RegisterRequest_User::email() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.RegisterRequest.User.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterRequest_User::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.RegisterRequest.User.email)
}
inline std::string* RegisterRequest_User::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.RegisterRequest.User.email)
  return _s;
}
inline const std::string& RegisterRequest_User::_internal_email() const {
  return email_.Get();
}
inline void RegisterRequest_User::_internal_set_email(const std::string& value) {
  
  email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegisterRequest_User::_internal_mutable_email() {
  
  return email_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegisterRequest_User::release_email() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.RegisterRequest.User.email)
  return email_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegisterRequest_User::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), email,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.RegisterRequest.User.email)
}

// string password = 3;
inline void RegisterRequest_User::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& RegisterRequest_User::password() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.RegisterRequest.User.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterRequest_User::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.RegisterRequest.User.password)
}
inline std::string* RegisterRequest_User::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.RegisterRequest.User.password)
  return _s;
}
inline const std::string& RegisterRequest_User::_internal_password() const {
  return password_.Get();
}
inline void RegisterRequest_User::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegisterRequest_User::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegisterRequest_User::release_password() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.RegisterRequest.User.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegisterRequest_User::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.RegisterRequest.User.password)
}

// -------------------------------------------------------------------

// RegisterRequest

// .bugu.service.v1.RegisterRequest.User user = 1;
inline bool RegisterRequest::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool RegisterRequest::has_user() const {
  return _internal_has_user();
}
inline void RegisterRequest::clear_user() {
  if (GetArenaForAllocation() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::bugu::service::v1::RegisterRequest_User& RegisterRequest::_internal_user() const {
  const ::bugu::service::v1::RegisterRequest_User* p = user_;
  return p != nullptr ? *p : reinterpret_cast<const ::bugu::service::v1::RegisterRequest_User&>(
      ::bugu::service::v1::_RegisterRequest_User_default_instance_);
}
inline const ::bugu::service::v1::RegisterRequest_User& RegisterRequest::user() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.RegisterRequest.user)
  return _internal_user();
}
inline void RegisterRequest::unsafe_arena_set_allocated_user(
    ::bugu::service::v1::RegisterRequest_User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bugu.service.v1.RegisterRequest.user)
}
inline ::bugu::service::v1::RegisterRequest_User* RegisterRequest::release_user() {
  
  ::bugu::service::v1::RegisterRequest_User* temp = user_;
  user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bugu::service::v1::RegisterRequest_User* RegisterRequest::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.RegisterRequest.user)
  
  ::bugu::service::v1::RegisterRequest_User* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::bugu::service::v1::RegisterRequest_User* RegisterRequest::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::bugu::service::v1::RegisterRequest_User>(GetArenaForAllocation());
    user_ = p;
  }
  return user_;
}
inline ::bugu::service::v1::RegisterRequest_User* RegisterRequest::mutable_user() {
  ::bugu::service::v1::RegisterRequest_User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.RegisterRequest.user)
  return _msg;
}
inline void RegisterRequest::set_allocated_user(::bugu::service::v1::RegisterRequest_User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bugu::service::v1::RegisterRequest_User>::GetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.RegisterRequest.user)
}

// -------------------------------------------------------------------

// RegisterReply

// .bugu.service.v1.UserStruct user = 1;
inline bool RegisterReply::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool RegisterReply::has_user() const {
  return _internal_has_user();
}
inline void RegisterReply::clear_user() {
  if (GetArenaForAllocation() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::bugu::service::v1::UserStruct& RegisterReply::_internal_user() const {
  const ::bugu::service::v1::UserStruct* p = user_;
  return p != nullptr ? *p : reinterpret_cast<const ::bugu::service::v1::UserStruct&>(
      ::bugu::service::v1::_UserStruct_default_instance_);
}
inline const ::bugu::service::v1::UserStruct& RegisterReply::user() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.RegisterReply.user)
  return _internal_user();
}
inline void RegisterReply::unsafe_arena_set_allocated_user(
    ::bugu::service::v1::UserStruct* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bugu.service.v1.RegisterReply.user)
}
inline ::bugu::service::v1::UserStruct* RegisterReply::release_user() {
  
  ::bugu::service::v1::UserStruct* temp = user_;
  user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bugu::service::v1::UserStruct* RegisterReply::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.RegisterReply.user)
  
  ::bugu::service::v1::UserStruct* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::bugu::service::v1::UserStruct* RegisterReply::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::bugu::service::v1::UserStruct>(GetArenaForAllocation());
    user_ = p;
  }
  return user_;
}
inline ::bugu::service::v1::UserStruct* RegisterReply::mutable_user() {
  ::bugu::service::v1::UserStruct* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.RegisterReply.user)
  return _msg;
}
inline void RegisterReply::set_allocated_user(::bugu::service::v1::UserStruct* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bugu::service::v1::UserStruct>::GetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.RegisterReply.user)
}

// -------------------------------------------------------------------

// LoginRequest_User

// string email = 1;
inline void LoginRequest_User::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& LoginRequest_User::email() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.LoginRequest.User.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest_User::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.LoginRequest.User.email)
}
inline std::string* LoginRequest_User::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.LoginRequest.User.email)
  return _s;
}
inline const std::string& LoginRequest_User::_internal_email() const {
  return email_.Get();
}
inline void LoginRequest_User::_internal_set_email(const std::string& value) {
  
  email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginRequest_User::_internal_mutable_email() {
  
  return email_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginRequest_User::release_email() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.LoginRequest.User.email)
  return email_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginRequest_User::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), email,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.LoginRequest.User.email)
}

// string password = 2;
inline void LoginRequest_User::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& LoginRequest_User::password() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.LoginRequest.User.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest_User::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.LoginRequest.User.password)
}
inline std::string* LoginRequest_User::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.LoginRequest.User.password)
  return _s;
}
inline const std::string& LoginRequest_User::_internal_password() const {
  return password_.Get();
}
inline void LoginRequest_User::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginRequest_User::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginRequest_User::release_password() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.LoginRequest.User.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginRequest_User::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.LoginRequest.User.password)
}

// -------------------------------------------------------------------

// LoginRequest

// .bugu.service.v1.LoginRequest.User user = 1;
inline bool LoginRequest::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool LoginRequest::has_user() const {
  return _internal_has_user();
}
inline void LoginRequest::clear_user() {
  if (GetArenaForAllocation() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::bugu::service::v1::LoginRequest_User& LoginRequest::_internal_user() const {
  const ::bugu::service::v1::LoginRequest_User* p = user_;
  return p != nullptr ? *p : reinterpret_cast<const ::bugu::service::v1::LoginRequest_User&>(
      ::bugu::service::v1::_LoginRequest_User_default_instance_);
}
inline const ::bugu::service::v1::LoginRequest_User& LoginRequest::user() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.LoginRequest.user)
  return _internal_user();
}
inline void LoginRequest::unsafe_arena_set_allocated_user(
    ::bugu::service::v1::LoginRequest_User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bugu.service.v1.LoginRequest.user)
}
inline ::bugu::service::v1::LoginRequest_User* LoginRequest::release_user() {
  
  ::bugu::service::v1::LoginRequest_User* temp = user_;
  user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bugu::service::v1::LoginRequest_User* LoginRequest::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.LoginRequest.user)
  
  ::bugu::service::v1::LoginRequest_User* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::bugu::service::v1::LoginRequest_User* LoginRequest::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::bugu::service::v1::LoginRequest_User>(GetArenaForAllocation());
    user_ = p;
  }
  return user_;
}
inline ::bugu::service::v1::LoginRequest_User* LoginRequest::mutable_user() {
  ::bugu::service::v1::LoginRequest_User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.LoginRequest.user)
  return _msg;
}
inline void LoginRequest::set_allocated_user(::bugu::service::v1::LoginRequest_User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bugu::service::v1::LoginRequest_User>::GetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.LoginRequest.user)
}

// -------------------------------------------------------------------

// LoginReply

// .bugu.service.v1.UserStruct user = 1;
inline bool LoginReply::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool LoginReply::has_user() const {
  return _internal_has_user();
}
inline void LoginReply::clear_user() {
  if (GetArenaForAllocation() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::bugu::service::v1::UserStruct& LoginReply::_internal_user() const {
  const ::bugu::service::v1::UserStruct* p = user_;
  return p != nullptr ? *p : reinterpret_cast<const ::bugu::service::v1::UserStruct&>(
      ::bugu::service::v1::_UserStruct_default_instance_);
}
inline const ::bugu::service::v1::UserStruct& LoginReply::user() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.LoginReply.user)
  return _internal_user();
}
inline void LoginReply::unsafe_arena_set_allocated_user(
    ::bugu::service::v1::UserStruct* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bugu.service.v1.LoginReply.user)
}
inline ::bugu::service::v1::UserStruct* LoginReply::release_user() {
  
  ::bugu::service::v1::UserStruct* temp = user_;
  user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bugu::service::v1::UserStruct* LoginReply::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.LoginReply.user)
  
  ::bugu::service::v1::UserStruct* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::bugu::service::v1::UserStruct* LoginReply::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::bugu::service::v1::UserStruct>(GetArenaForAllocation());
    user_ = p;
  }
  return user_;
}
inline ::bugu::service::v1::UserStruct* LoginReply::mutable_user() {
  ::bugu::service::v1::UserStruct* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.LoginReply.user)
  return _msg;
}
inline void LoginReply::set_allocated_user(::bugu::service::v1::UserStruct* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bugu::service::v1::UserStruct>::GetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.LoginReply.user)
}

// string token = 2;
inline void LoginReply::clear_token() {
  token_.ClearToEmpty();
}
inline const std::string& LoginReply::token() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.LoginReply.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginReply::set_token(ArgT0&& arg0, ArgT... args) {
 
 token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.LoginReply.token)
}
inline std::string* LoginReply::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.LoginReply.token)
  return _s;
}
inline const std::string& LoginReply::_internal_token() const {
  return token_.Get();
}
inline void LoginReply::_internal_set_token(const std::string& value) {
  
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginReply::_internal_mutable_token() {
  
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginReply::release_token() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.LoginReply.token)
  return token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginReply::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.LoginReply.token)
}

// -------------------------------------------------------------------

// GetCurrentUserRequest

// string id = 1 [(.validate.rules) = {
inline void GetCurrentUserRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetCurrentUserRequest::id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetCurrentUserRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetCurrentUserRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetCurrentUserRequest.id)
}
inline std::string* GetCurrentUserRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetCurrentUserRequest.id)
  return _s;
}
inline const std::string& GetCurrentUserRequest::_internal_id() const {
  return id_.Get();
}
inline void GetCurrentUserRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetCurrentUserRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetCurrentUserRequest::release_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetCurrentUserRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetCurrentUserRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetCurrentUserRequest.id)
}

// -------------------------------------------------------------------

// GetCurrentUserReply

// .bugu.service.v1.UserStruct user = 1;
inline bool GetCurrentUserReply::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool GetCurrentUserReply::has_user() const {
  return _internal_has_user();
}
inline void GetCurrentUserReply::clear_user() {
  if (GetArenaForAllocation() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::bugu::service::v1::UserStruct& GetCurrentUserReply::_internal_user() const {
  const ::bugu::service::v1::UserStruct* p = user_;
  return p != nullptr ? *p : reinterpret_cast<const ::bugu::service::v1::UserStruct&>(
      ::bugu::service::v1::_UserStruct_default_instance_);
}
inline const ::bugu::service::v1::UserStruct& GetCurrentUserReply::user() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetCurrentUserReply.user)
  return _internal_user();
}
inline void GetCurrentUserReply::unsafe_arena_set_allocated_user(
    ::bugu::service::v1::UserStruct* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bugu.service.v1.GetCurrentUserReply.user)
}
inline ::bugu::service::v1::UserStruct* GetCurrentUserReply::release_user() {
  
  ::bugu::service::v1::UserStruct* temp = user_;
  user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bugu::service::v1::UserStruct* GetCurrentUserReply::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetCurrentUserReply.user)
  
  ::bugu::service::v1::UserStruct* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::bugu::service::v1::UserStruct* GetCurrentUserReply::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::bugu::service::v1::UserStruct>(GetArenaForAllocation());
    user_ = p;
  }
  return user_;
}
inline ::bugu::service::v1::UserStruct* GetCurrentUserReply::mutable_user() {
  ::bugu::service::v1::UserStruct* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetCurrentUserReply.user)
  return _msg;
}
inline void GetCurrentUserReply::set_allocated_user(::bugu::service::v1::UserStruct* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bugu::service::v1::UserStruct>::GetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetCurrentUserReply.user)
}

// -------------------------------------------------------------------

// UpdateUserRequest_User

// string id = 1;
inline void UpdateUserRequest_User::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& UpdateUserRequest_User::id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.UpdateUserRequest.User.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateUserRequest_User::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.UpdateUserRequest.User.id)
}
inline std::string* UpdateUserRequest_User::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.UpdateUserRequest.User.id)
  return _s;
}
inline const std::string& UpdateUserRequest_User::_internal_id() const {
  return id_.Get();
}
inline void UpdateUserRequest_User::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateUserRequest_User::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateUserRequest_User::release_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.UpdateUserRequest.User.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateUserRequest_User::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.UpdateUserRequest.User.id)
}

// string email = 2;
inline void UpdateUserRequest_User::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& UpdateUserRequest_User::email() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.UpdateUserRequest.User.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateUserRequest_User::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.UpdateUserRequest.User.email)
}
inline std::string* UpdateUserRequest_User::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.UpdateUserRequest.User.email)
  return _s;
}
inline const std::string& UpdateUserRequest_User::_internal_email() const {
  return email_.Get();
}
inline void UpdateUserRequest_User::_internal_set_email(const std::string& value) {
  
  email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateUserRequest_User::_internal_mutable_email() {
  
  return email_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateUserRequest_User::release_email() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.UpdateUserRequest.User.email)
  return email_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateUserRequest_User::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), email,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.UpdateUserRequest.User.email)
}

// string username = 4;
inline void UpdateUserRequest_User::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& UpdateUserRequest_User::username() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.UpdateUserRequest.User.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateUserRequest_User::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.UpdateUserRequest.User.username)
}
inline std::string* UpdateUserRequest_User::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.UpdateUserRequest.User.username)
  return _s;
}
inline const std::string& UpdateUserRequest_User::_internal_username() const {
  return username_.Get();
}
inline void UpdateUserRequest_User::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateUserRequest_User::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateUserRequest_User::release_username() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.UpdateUserRequest.User.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateUserRequest_User::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.UpdateUserRequest.User.username)
}

// string password = 5;
inline void UpdateUserRequest_User::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& UpdateUserRequest_User::password() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.UpdateUserRequest.User.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateUserRequest_User::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.UpdateUserRequest.User.password)
}
inline std::string* UpdateUserRequest_User::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.UpdateUserRequest.User.password)
  return _s;
}
inline const std::string& UpdateUserRequest_User::_internal_password() const {
  return password_.Get();
}
inline void UpdateUserRequest_User::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateUserRequest_User::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateUserRequest_User::release_password() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.UpdateUserRequest.User.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateUserRequest_User::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.UpdateUserRequest.User.password)
}

// -------------------------------------------------------------------

// UpdateUserRequest

// .bugu.service.v1.UpdateUserRequest.User user = 1;
inline bool UpdateUserRequest::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool UpdateUserRequest::has_user() const {
  return _internal_has_user();
}
inline void UpdateUserRequest::clear_user() {
  if (GetArenaForAllocation() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::bugu::service::v1::UpdateUserRequest_User& UpdateUserRequest::_internal_user() const {
  const ::bugu::service::v1::UpdateUserRequest_User* p = user_;
  return p != nullptr ? *p : reinterpret_cast<const ::bugu::service::v1::UpdateUserRequest_User&>(
      ::bugu::service::v1::_UpdateUserRequest_User_default_instance_);
}
inline const ::bugu::service::v1::UpdateUserRequest_User& UpdateUserRequest::user() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.UpdateUserRequest.user)
  return _internal_user();
}
inline void UpdateUserRequest::unsafe_arena_set_allocated_user(
    ::bugu::service::v1::UpdateUserRequest_User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bugu.service.v1.UpdateUserRequest.user)
}
inline ::bugu::service::v1::UpdateUserRequest_User* UpdateUserRequest::release_user() {
  
  ::bugu::service::v1::UpdateUserRequest_User* temp = user_;
  user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bugu::service::v1::UpdateUserRequest_User* UpdateUserRequest::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.UpdateUserRequest.user)
  
  ::bugu::service::v1::UpdateUserRequest_User* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::bugu::service::v1::UpdateUserRequest_User* UpdateUserRequest::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::bugu::service::v1::UpdateUserRequest_User>(GetArenaForAllocation());
    user_ = p;
  }
  return user_;
}
inline ::bugu::service::v1::UpdateUserRequest_User* UpdateUserRequest::mutable_user() {
  ::bugu::service::v1::UpdateUserRequest_User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.UpdateUserRequest.user)
  return _msg;
}
inline void UpdateUserRequest::set_allocated_user(::bugu::service::v1::UpdateUserRequest_User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bugu::service::v1::UpdateUserRequest_User>::GetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.UpdateUserRequest.user)
}

// -------------------------------------------------------------------

// UpdateUserReply

// .bugu.service.v1.UserStruct user = 1;
inline bool UpdateUserReply::_internal_has_user() const {
  return this != internal_default_instance() && user_ != nullptr;
}
inline bool UpdateUserReply::has_user() const {
  return _internal_has_user();
}
inline void UpdateUserReply::clear_user() {
  if (GetArenaForAllocation() == nullptr && user_ != nullptr) {
    delete user_;
  }
  user_ = nullptr;
}
inline const ::bugu::service::v1::UserStruct& UpdateUserReply::_internal_user() const {
  const ::bugu::service::v1::UserStruct* p = user_;
  return p != nullptr ? *p : reinterpret_cast<const ::bugu::service::v1::UserStruct&>(
      ::bugu::service::v1::_UserStruct_default_instance_);
}
inline const ::bugu::service::v1::UserStruct& UpdateUserReply::user() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.UpdateUserReply.user)
  return _internal_user();
}
inline void UpdateUserReply::unsafe_arena_set_allocated_user(
    ::bugu::service::v1::UserStruct* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_);
  }
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bugu.service.v1.UpdateUserReply.user)
}
inline ::bugu::service::v1::UserStruct* UpdateUserReply::release_user() {
  
  ::bugu::service::v1::UserStruct* temp = user_;
  user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bugu::service::v1::UserStruct* UpdateUserReply::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.UpdateUserReply.user)
  
  ::bugu::service::v1::UserStruct* temp = user_;
  user_ = nullptr;
  return temp;
}
inline ::bugu::service::v1::UserStruct* UpdateUserReply::_internal_mutable_user() {
  
  if (user_ == nullptr) {
    auto* p = CreateMaybeMessage<::bugu::service::v1::UserStruct>(GetArenaForAllocation());
    user_ = p;
  }
  return user_;
}
inline ::bugu::service::v1::UserStruct* UpdateUserReply::mutable_user() {
  ::bugu::service::v1::UserStruct* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.UpdateUserReply.user)
  return _msg;
}
inline void UpdateUserReply::set_allocated_user(::bugu::service::v1::UserStruct* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bugu::service::v1::UserStruct>::GetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.UpdateUserReply.user)
}

// -------------------------------------------------------------------

// UserStruct

// string id = 1 [(.validate.rules) = {
inline void UserStruct::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& UserStruct::id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.UserStruct.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserStruct::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.UserStruct.id)
}
inline std::string* UserStruct::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.UserStruct.id)
  return _s;
}
inline const std::string& UserStruct::_internal_id() const {
  return id_.Get();
}
inline void UserStruct::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserStruct::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserStruct::release_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.UserStruct.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserStruct::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.UserStruct.id)
}

// string email = 2;
inline void UserStruct::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& UserStruct::email() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.UserStruct.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserStruct::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.UserStruct.email)
}
inline std::string* UserStruct::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.UserStruct.email)
  return _s;
}
inline const std::string& UserStruct::_internal_email() const {
  return email_.Get();
}
inline void UserStruct::_internal_set_email(const std::string& value) {
  
  email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserStruct::_internal_mutable_email() {
  
  return email_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserStruct::release_email() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.UserStruct.email)
  return email_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserStruct::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), email,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.UserStruct.email)
}

// string username = 3;
inline void UserStruct::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& UserStruct::username() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.UserStruct.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserStruct::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.UserStruct.username)
}
inline std::string* UserStruct::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.UserStruct.username)
  return _s;
}
inline const std::string& UserStruct::_internal_username() const {
  return username_.Get();
}
inline void UserStruct::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserStruct::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserStruct::release_username() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.UserStruct.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserStruct::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.UserStruct.username)
}

// -------------------------------------------------------------------

// GetFileMetaRequest

// string user_id = 1 [(.validate.rules) = {
inline void GetFileMetaRequest::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& GetFileMetaRequest::user_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetFileMetaRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFileMetaRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetFileMetaRequest.user_id)
}
inline std::string* GetFileMetaRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetFileMetaRequest.user_id)
  return _s;
}
inline const std::string& GetFileMetaRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void GetFileMetaRequest::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetFileMetaRequest::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetFileMetaRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetFileMetaRequest.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetFileMetaRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetFileMetaRequest.user_id)
}

// string file_id = 2 [(.validate.rules) = {
inline void GetFileMetaRequest::clear_file_id() {
  file_id_.ClearToEmpty();
}
inline const std::string& GetFileMetaRequest::file_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetFileMetaRequest.file_id)
  return _internal_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFileMetaRequest::set_file_id(ArgT0&& arg0, ArgT... args) {
 
 file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetFileMetaRequest.file_id)
}
inline std::string* GetFileMetaRequest::mutable_file_id() {
  std::string* _s = _internal_mutable_file_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetFileMetaRequest.file_id)
  return _s;
}
inline const std::string& GetFileMetaRequest::_internal_file_id() const {
  return file_id_.Get();
}
inline void GetFileMetaRequest::_internal_set_file_id(const std::string& value) {
  
  file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetFileMetaRequest::_internal_mutable_file_id() {
  
  return file_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetFileMetaRequest::release_file_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetFileMetaRequest.file_id)
  return file_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetFileMetaRequest::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    
  } else {
    
  }
  file_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetFileMetaRequest.file_id)
}

// -------------------------------------------------------------------

// GetFileMetaReply

// string file_id = 1 [(.validate.rules) = {
inline void GetFileMetaReply::clear_file_id() {
  file_id_.ClearToEmpty();
}
inline const std::string& GetFileMetaReply::file_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetFileMetaReply.file_id)
  return _internal_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFileMetaReply::set_file_id(ArgT0&& arg0, ArgT... args) {
 
 file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetFileMetaReply.file_id)
}
inline std::string* GetFileMetaReply::mutable_file_id() {
  std::string* _s = _internal_mutable_file_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetFileMetaReply.file_id)
  return _s;
}
inline const std::string& GetFileMetaReply::_internal_file_id() const {
  return file_id_.Get();
}
inline void GetFileMetaReply::_internal_set_file_id(const std::string& value) {
  
  file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetFileMetaReply::_internal_mutable_file_id() {
  
  return file_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetFileMetaReply::release_file_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetFileMetaReply.file_id)
  return file_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetFileMetaReply::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    
  } else {
    
  }
  file_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetFileMetaReply.file_id)
}

// string file_sha_1 = 2;
inline void GetFileMetaReply::clear_file_sha_1() {
  file_sha_1_.ClearToEmpty();
}
inline const std::string& GetFileMetaReply::file_sha_1() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetFileMetaReply.file_sha_1)
  return _internal_file_sha_1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFileMetaReply::set_file_sha_1(ArgT0&& arg0, ArgT... args) {
 
 file_sha_1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetFileMetaReply.file_sha_1)
}
inline std::string* GetFileMetaReply::mutable_file_sha_1() {
  std::string* _s = _internal_mutable_file_sha_1();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetFileMetaReply.file_sha_1)
  return _s;
}
inline const std::string& GetFileMetaReply::_internal_file_sha_1() const {
  return file_sha_1_.Get();
}
inline void GetFileMetaReply::_internal_set_file_sha_1(const std::string& value) {
  
  file_sha_1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetFileMetaReply::_internal_mutable_file_sha_1() {
  
  return file_sha_1_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetFileMetaReply::release_file_sha_1() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetFileMetaReply.file_sha_1)
  return file_sha_1_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetFileMetaReply::set_allocated_file_sha_1(std::string* file_sha_1) {
  if (file_sha_1 != nullptr) {
    
  } else {
    
  }
  file_sha_1_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_sha_1,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_sha_1_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_sha_1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetFileMetaReply.file_sha_1)
}

// int64 file_size = 3;
inline void GetFileMetaReply::clear_file_size() {
  file_size_ = int64_t{0};
}
inline int64_t GetFileMetaReply::_internal_file_size() const {
  return file_size_;
}
inline int64_t GetFileMetaReply::file_size() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetFileMetaReply.file_size)
  return _internal_file_size();
}
inline void GetFileMetaReply::_internal_set_file_size(int64_t value) {
  
  file_size_ = value;
}
inline void GetFileMetaReply::set_file_size(int64_t value) {
  _internal_set_file_size(value);
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetFileMetaReply.file_size)
}

// string file_addr = 4;
inline void GetFileMetaReply::clear_file_addr() {
  file_addr_.ClearToEmpty();
}
inline const std::string& GetFileMetaReply::file_addr() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetFileMetaReply.file_addr)
  return _internal_file_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFileMetaReply::set_file_addr(ArgT0&& arg0, ArgT... args) {
 
 file_addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetFileMetaReply.file_addr)
}
inline std::string* GetFileMetaReply::mutable_file_addr() {
  std::string* _s = _internal_mutable_file_addr();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetFileMetaReply.file_addr)
  return _s;
}
inline const std::string& GetFileMetaReply::_internal_file_addr() const {
  return file_addr_.Get();
}
inline void GetFileMetaReply::_internal_set_file_addr(const std::string& value) {
  
  file_addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetFileMetaReply::_internal_mutable_file_addr() {
  
  return file_addr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetFileMetaReply::release_file_addr() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetFileMetaReply.file_addr)
  return file_addr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetFileMetaReply::set_allocated_file_addr(std::string* file_addr) {
  if (file_addr != nullptr) {
    
  } else {
    
  }
  file_addr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_addr,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_addr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetFileMetaReply.file_addr)
}

// .bugu.service.v1.Type type = 5;
inline void GetFileMetaReply::clear_type() {
  type_ = 0;
}
inline ::bugu::service::v1::Type GetFileMetaReply::_internal_type() const {
  return static_cast< ::bugu::service::v1::Type >(type_);
}
inline ::bugu::service::v1::Type GetFileMetaReply::type() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetFileMetaReply.type)
  return _internal_type();
}
inline void GetFileMetaReply::_internal_set_type(::bugu::service::v1::Type value) {
  
  type_ = value;
}
inline void GetFileMetaReply::set_type(::bugu::service::v1::Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetFileMetaReply.type)
}

// -------------------------------------------------------------------

// GetFileMetaByUserIdRequest

// string user_id = 1 [(.validate.rules) = {
inline void GetFileMetaByUserIdRequest::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& GetFileMetaByUserIdRequest::user_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetFileMetaByUserIdRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFileMetaByUserIdRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetFileMetaByUserIdRequest.user_id)
}
inline std::string* GetFileMetaByUserIdRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetFileMetaByUserIdRequest.user_id)
  return _s;
}
inline const std::string& GetFileMetaByUserIdRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void GetFileMetaByUserIdRequest::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetFileMetaByUserIdRequest::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetFileMetaByUserIdRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetFileMetaByUserIdRequest.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetFileMetaByUserIdRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetFileMetaByUserIdRequest.user_id)
}

// -------------------------------------------------------------------

// GetFileMetaByUserIdReply

// repeated .bugu.service.v1.GetFileMetaReply file_metadata = 1;
inline int GetFileMetaByUserIdReply::_internal_file_metadata_size() const {
  return file_metadata_.size();
}
inline int GetFileMetaByUserIdReply::file_metadata_size() const {
  return _internal_file_metadata_size();
}
inline void GetFileMetaByUserIdReply::clear_file_metadata() {
  file_metadata_.Clear();
}
inline ::bugu::service::v1::GetFileMetaReply* GetFileMetaByUserIdReply::mutable_file_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetFileMetaByUserIdReply.file_metadata)
  return file_metadata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bugu::service::v1::GetFileMetaReply >*
GetFileMetaByUserIdReply::mutable_file_metadata() {
  // @@protoc_insertion_point(field_mutable_list:bugu.service.v1.GetFileMetaByUserIdReply.file_metadata)
  return &file_metadata_;
}
inline const ::bugu::service::v1::GetFileMetaReply& GetFileMetaByUserIdReply::_internal_file_metadata(int index) const {
  return file_metadata_.Get(index);
}
inline const ::bugu::service::v1::GetFileMetaReply& GetFileMetaByUserIdReply::file_metadata(int index) const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetFileMetaByUserIdReply.file_metadata)
  return _internal_file_metadata(index);
}
inline ::bugu::service::v1::GetFileMetaReply* GetFileMetaByUserIdReply::_internal_add_file_metadata() {
  return file_metadata_.Add();
}
inline ::bugu::service::v1::GetFileMetaReply* GetFileMetaByUserIdReply::add_file_metadata() {
  ::bugu::service::v1::GetFileMetaReply* _add = _internal_add_file_metadata();
  // @@protoc_insertion_point(field_add:bugu.service.v1.GetFileMetaByUserIdReply.file_metadata)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bugu::service::v1::GetFileMetaReply >&
GetFileMetaByUserIdReply::file_metadata() const {
  // @@protoc_insertion_point(field_list:bugu.service.v1.GetFileMetaByUserIdReply.file_metadata)
  return file_metadata_;
}

// -------------------------------------------------------------------

// DeleteFileMetadataRequest

// string user_id = 1 [(.validate.rules) = {
inline void DeleteFileMetadataRequest::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& DeleteFileMetadataRequest::user_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.DeleteFileMetadataRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteFileMetadataRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.DeleteFileMetadataRequest.user_id)
}
inline std::string* DeleteFileMetadataRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.DeleteFileMetadataRequest.user_id)
  return _s;
}
inline const std::string& DeleteFileMetadataRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void DeleteFileMetadataRequest::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteFileMetadataRequest::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteFileMetadataRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.DeleteFileMetadataRequest.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteFileMetadataRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.DeleteFileMetadataRequest.user_id)
}

// string file_id = 2 [(.validate.rules) = {
inline void DeleteFileMetadataRequest::clear_file_id() {
  file_id_.ClearToEmpty();
}
inline const std::string& DeleteFileMetadataRequest::file_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.DeleteFileMetadataRequest.file_id)
  return _internal_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteFileMetadataRequest::set_file_id(ArgT0&& arg0, ArgT... args) {
 
 file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.DeleteFileMetadataRequest.file_id)
}
inline std::string* DeleteFileMetadataRequest::mutable_file_id() {
  std::string* _s = _internal_mutable_file_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.DeleteFileMetadataRequest.file_id)
  return _s;
}
inline const std::string& DeleteFileMetadataRequest::_internal_file_id() const {
  return file_id_.Get();
}
inline void DeleteFileMetadataRequest::_internal_set_file_id(const std::string& value) {
  
  file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteFileMetadataRequest::_internal_mutable_file_id() {
  
  return file_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteFileMetadataRequest::release_file_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.DeleteFileMetadataRequest.file_id)
  return file_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteFileMetadataRequest::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    
  } else {
    
  }
  file_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.DeleteFileMetadataRequest.file_id)
}

// -------------------------------------------------------------------

// DeleteFileMetadataReply

// -------------------------------------------------------------------

// DetectRequest

// string user_id = 1 [(.validate.rules) = {
inline void DetectRequest::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& DetectRequest::user_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.DetectRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetectRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.DetectRequest.user_id)
}
inline std::string* DetectRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.DetectRequest.user_id)
  return _s;
}
inline const std::string& DetectRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void DetectRequest::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DetectRequest::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DetectRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.DetectRequest.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DetectRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.DetectRequest.user_id)
}

// string file_id = 2 [(.validate.rules) = {
inline void DetectRequest::clear_file_id() {
  file_id_.ClearToEmpty();
}
inline const std::string& DetectRequest::file_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.DetectRequest.file_id)
  return _internal_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetectRequest::set_file_id(ArgT0&& arg0, ArgT... args) {
 
 file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.DetectRequest.file_id)
}
inline std::string* DetectRequest::mutable_file_id() {
  std::string* _s = _internal_mutable_file_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.DetectRequest.file_id)
  return _s;
}
inline const std::string& DetectRequest::_internal_file_id() const {
  return file_id_.Get();
}
inline void DetectRequest::_internal_set_file_id(const std::string& value) {
  
  file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DetectRequest::_internal_mutable_file_id() {
  
  return file_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DetectRequest::release_file_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.DetectRequest.file_id)
  return file_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DetectRequest::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    
  } else {
    
  }
  file_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.DetectRequest.file_id)
}

// -------------------------------------------------------------------

// DetectReply

// string artifact_id = 1 [(.validate.rules) = {
inline void DetectReply::clear_artifact_id() {
  artifact_id_.ClearToEmpty();
}
inline const std::string& DetectReply::artifact_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.DetectReply.artifact_id)
  return _internal_artifact_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetectReply::set_artifact_id(ArgT0&& arg0, ArgT... args) {
 
 artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.DetectReply.artifact_id)
}
inline std::string* DetectReply::mutable_artifact_id() {
  std::string* _s = _internal_mutable_artifact_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.DetectReply.artifact_id)
  return _s;
}
inline const std::string& DetectReply::_internal_artifact_id() const {
  return artifact_id_.Get();
}
inline void DetectReply::_internal_set_artifact_id(const std::string& value) {
  
  artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DetectReply::_internal_mutable_artifact_id() {
  
  return artifact_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DetectReply::release_artifact_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.DetectReply.artifact_id)
  return artifact_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DetectReply::set_allocated_artifact_id(std::string* artifact_id) {
  if (artifact_id != nullptr) {
    
  } else {
    
  }
  artifact_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), artifact_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (artifact_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    artifact_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.DetectReply.artifact_id)
}

// -------------------------------------------------------------------

// ConfusionRequest

// string user_id = 1 [(.validate.rules) = {
inline void ConfusionRequest::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& ConfusionRequest::user_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.ConfusionRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfusionRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.ConfusionRequest.user_id)
}
inline std::string* ConfusionRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.ConfusionRequest.user_id)
  return _s;
}
inline const std::string& ConfusionRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void ConfusionRequest::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfusionRequest::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfusionRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.ConfusionRequest.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConfusionRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.ConfusionRequest.user_id)
}

// string file_id = 2 [(.validate.rules) = {
inline void ConfusionRequest::clear_file_id() {
  file_id_.ClearToEmpty();
}
inline const std::string& ConfusionRequest::file_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.ConfusionRequest.file_id)
  return _internal_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfusionRequest::set_file_id(ArgT0&& arg0, ArgT... args) {
 
 file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.ConfusionRequest.file_id)
}
inline std::string* ConfusionRequest::mutable_file_id() {
  std::string* _s = _internal_mutable_file_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.ConfusionRequest.file_id)
  return _s;
}
inline const std::string& ConfusionRequest::_internal_file_id() const {
  return file_id_.Get();
}
inline void ConfusionRequest::_internal_set_file_id(const std::string& value) {
  
  file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfusionRequest::_internal_mutable_file_id() {
  
  return file_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfusionRequest::release_file_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.ConfusionRequest.file_id)
  return file_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConfusionRequest::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    
  } else {
    
  }
  file_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.ConfusionRequest.file_id)
}

// -------------------------------------------------------------------

// ConfusionReply

// string artifact_id = 1 [(.validate.rules) = {
inline void ConfusionReply::clear_artifact_id() {
  artifact_id_.ClearToEmpty();
}
inline const std::string& ConfusionReply::artifact_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.ConfusionReply.artifact_id)
  return _internal_artifact_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfusionReply::set_artifact_id(ArgT0&& arg0, ArgT... args) {
 
 artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.ConfusionReply.artifact_id)
}
inline std::string* ConfusionReply::mutable_artifact_id() {
  std::string* _s = _internal_mutable_artifact_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.ConfusionReply.artifact_id)
  return _s;
}
inline const std::string& ConfusionReply::_internal_artifact_id() const {
  return artifact_id_.Get();
}
inline void ConfusionReply::_internal_set_artifact_id(const std::string& value) {
  
  artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfusionReply::_internal_mutable_artifact_id() {
  
  return artifact_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfusionReply::release_artifact_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.ConfusionReply.artifact_id)
  return artifact_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConfusionReply::set_allocated_artifact_id(std::string* artifact_id) {
  if (artifact_id != nullptr) {
    
  } else {
    
  }
  artifact_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), artifact_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (artifact_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    artifact_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.ConfusionReply.artifact_id)
}

// string file_id = 2 [(.validate.rules) = {
inline void ConfusionReply::clear_file_id() {
  file_id_.ClearToEmpty();
}
inline const std::string& ConfusionReply::file_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.ConfusionReply.file_id)
  return _internal_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfusionReply::set_file_id(ArgT0&& arg0, ArgT... args) {
 
 file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.ConfusionReply.file_id)
}
inline std::string* ConfusionReply::mutable_file_id() {
  std::string* _s = _internal_mutable_file_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.ConfusionReply.file_id)
  return _s;
}
inline const std::string& ConfusionReply::_internal_file_id() const {
  return file_id_.Get();
}
inline void ConfusionReply::_internal_set_file_id(const std::string& value) {
  
  file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfusionReply::_internal_mutable_file_id() {
  
  return file_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfusionReply::release_file_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.ConfusionReply.file_id)
  return file_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConfusionReply::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    
  } else {
    
  }
  file_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.ConfusionReply.file_id)
}

// string affiliated_file_id = 3 [(.validate.rules) = {
inline void ConfusionReply::clear_affiliated_file_id() {
  affiliated_file_id_.ClearToEmpty();
}
inline const std::string& ConfusionReply::affiliated_file_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.ConfusionReply.affiliated_file_id)
  return _internal_affiliated_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfusionReply::set_affiliated_file_id(ArgT0&& arg0, ArgT... args) {
 
 affiliated_file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.ConfusionReply.affiliated_file_id)
}
inline std::string* ConfusionReply::mutable_affiliated_file_id() {
  std::string* _s = _internal_mutable_affiliated_file_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.ConfusionReply.affiliated_file_id)
  return _s;
}
inline const std::string& ConfusionReply::_internal_affiliated_file_id() const {
  return affiliated_file_id_.Get();
}
inline void ConfusionReply::_internal_set_affiliated_file_id(const std::string& value) {
  
  affiliated_file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfusionReply::_internal_mutable_affiliated_file_id() {
  
  return affiliated_file_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfusionReply::release_affiliated_file_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.ConfusionReply.affiliated_file_id)
  return affiliated_file_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConfusionReply::set_allocated_affiliated_file_id(std::string* affiliated_file_id) {
  if (affiliated_file_id != nullptr) {
    
  } else {
    
  }
  affiliated_file_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), affiliated_file_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (affiliated_file_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    affiliated_file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.ConfusionReply.affiliated_file_id)
}

// string method = 4;
inline void ConfusionReply::clear_method() {
  method_.ClearToEmpty();
}
inline const std::string& ConfusionReply::method() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.ConfusionReply.method)
  return _internal_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfusionReply::set_method(ArgT0&& arg0, ArgT... args) {
 
 method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.ConfusionReply.method)
}
inline std::string* ConfusionReply::mutable_method() {
  std::string* _s = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.ConfusionReply.method)
  return _s;
}
inline const std::string& ConfusionReply::_internal_method() const {
  return method_.Get();
}
inline void ConfusionReply::_internal_set_method(const std::string& value) {
  
  method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfusionReply::_internal_mutable_method() {
  
  return method_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfusionReply::release_method() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.ConfusionReply.method)
  return method_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConfusionReply::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  method_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), method,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (method_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.ConfusionReply.method)
}

// -------------------------------------------------------------------

// GetArtifactMetadataRequest

// string user_id = 1 [(.validate.rules) = {
inline void GetArtifactMetadataRequest::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& GetArtifactMetadataRequest::user_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetArtifactMetadataRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetArtifactMetadataRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetArtifactMetadataRequest.user_id)
}
inline std::string* GetArtifactMetadataRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetArtifactMetadataRequest.user_id)
  return _s;
}
inline const std::string& GetArtifactMetadataRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void GetArtifactMetadataRequest::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataRequest::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetArtifactMetadataRequest.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetArtifactMetadataRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetArtifactMetadataRequest.user_id)
}

// string artifact_id = 2 [(.validate.rules) = {
inline void GetArtifactMetadataRequest::clear_artifact_id() {
  artifact_id_.ClearToEmpty();
}
inline const std::string& GetArtifactMetadataRequest::artifact_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetArtifactMetadataRequest.artifact_id)
  return _internal_artifact_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetArtifactMetadataRequest::set_artifact_id(ArgT0&& arg0, ArgT... args) {
 
 artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetArtifactMetadataRequest.artifact_id)
}
inline std::string* GetArtifactMetadataRequest::mutable_artifact_id() {
  std::string* _s = _internal_mutable_artifact_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetArtifactMetadataRequest.artifact_id)
  return _s;
}
inline const std::string& GetArtifactMetadataRequest::_internal_artifact_id() const {
  return artifact_id_.Get();
}
inline void GetArtifactMetadataRequest::_internal_set_artifact_id(const std::string& value) {
  
  artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataRequest::_internal_mutable_artifact_id() {
  
  return artifact_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataRequest::release_artifact_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetArtifactMetadataRequest.artifact_id)
  return artifact_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetArtifactMetadataRequest::set_allocated_artifact_id(std::string* artifact_id) {
  if (artifact_id != nullptr) {
    
  } else {
    
  }
  artifact_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), artifact_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (artifact_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    artifact_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetArtifactMetadataRequest.artifact_id)
}

// -------------------------------------------------------------------

// GetArtifactMetadataReply

// string artifact_id = 1 [(.validate.rules) = {
inline void GetArtifactMetadataReply::clear_artifact_id() {
  artifact_id_.ClearToEmpty();
}
inline const std::string& GetArtifactMetadataReply::artifact_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetArtifactMetadataReply.artifact_id)
  return _internal_artifact_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetArtifactMetadataReply::set_artifact_id(ArgT0&& arg0, ArgT... args) {
 
 artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetArtifactMetadataReply.artifact_id)
}
inline std::string* GetArtifactMetadataReply::mutable_artifact_id() {
  std::string* _s = _internal_mutable_artifact_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetArtifactMetadataReply.artifact_id)
  return _s;
}
inline const std::string& GetArtifactMetadataReply::_internal_artifact_id() const {
  return artifact_id_.Get();
}
inline void GetArtifactMetadataReply::_internal_set_artifact_id(const std::string& value) {
  
  artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataReply::_internal_mutable_artifact_id() {
  
  return artifact_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataReply::release_artifact_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetArtifactMetadataReply.artifact_id)
  return artifact_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetArtifactMetadataReply::set_allocated_artifact_id(std::string* artifact_id) {
  if (artifact_id != nullptr) {
    
  } else {
    
  }
  artifact_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), artifact_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (artifact_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    artifact_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetArtifactMetadataReply.artifact_id)
}

// string file_id = 2 [(.validate.rules) = {
inline void GetArtifactMetadataReply::clear_file_id() {
  file_id_.ClearToEmpty();
}
inline const std::string& GetArtifactMetadataReply::file_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetArtifactMetadataReply.file_id)
  return _internal_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetArtifactMetadataReply::set_file_id(ArgT0&& arg0, ArgT... args) {
 
 file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetArtifactMetadataReply.file_id)
}
inline std::string* GetArtifactMetadataReply::mutable_file_id() {
  std::string* _s = _internal_mutable_file_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetArtifactMetadataReply.file_id)
  return _s;
}
inline const std::string& GetArtifactMetadataReply::_internal_file_id() const {
  return file_id_.Get();
}
inline void GetArtifactMetadataReply::_internal_set_file_id(const std::string& value) {
  
  file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataReply::_internal_mutable_file_id() {
  
  return file_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataReply::release_file_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetArtifactMetadataReply.file_id)
  return file_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetArtifactMetadataReply::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    
  } else {
    
  }
  file_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetArtifactMetadataReply.file_id)
}

// string affiliated_file_id = 3 [(.validate.rules) = {
inline void GetArtifactMetadataReply::clear_affiliated_file_id() {
  affiliated_file_id_.ClearToEmpty();
}
inline const std::string& GetArtifactMetadataReply::affiliated_file_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetArtifactMetadataReply.affiliated_file_id)
  return _internal_affiliated_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetArtifactMetadataReply::set_affiliated_file_id(ArgT0&& arg0, ArgT... args) {
 
 affiliated_file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetArtifactMetadataReply.affiliated_file_id)
}
inline std::string* GetArtifactMetadataReply::mutable_affiliated_file_id() {
  std::string* _s = _internal_mutable_affiliated_file_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetArtifactMetadataReply.affiliated_file_id)
  return _s;
}
inline const std::string& GetArtifactMetadataReply::_internal_affiliated_file_id() const {
  return affiliated_file_id_.Get();
}
inline void GetArtifactMetadataReply::_internal_set_affiliated_file_id(const std::string& value) {
  
  affiliated_file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataReply::_internal_mutable_affiliated_file_id() {
  
  return affiliated_file_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataReply::release_affiliated_file_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetArtifactMetadataReply.affiliated_file_id)
  return affiliated_file_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetArtifactMetadataReply::set_allocated_affiliated_file_id(std::string* affiliated_file_id) {
  if (affiliated_file_id != nullptr) {
    
  } else {
    
  }
  affiliated_file_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), affiliated_file_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (affiliated_file_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    affiliated_file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetArtifactMetadataReply.affiliated_file_id)
}

// string method = 4;
inline void GetArtifactMetadataReply::clear_method() {
  method_.ClearToEmpty();
}
inline const std::string& GetArtifactMetadataReply::method() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetArtifactMetadataReply.method)
  return _internal_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetArtifactMetadataReply::set_method(ArgT0&& arg0, ArgT... args) {
 
 method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetArtifactMetadataReply.method)
}
inline std::string* GetArtifactMetadataReply::mutable_method() {
  std::string* _s = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetArtifactMetadataReply.method)
  return _s;
}
inline const std::string& GetArtifactMetadataReply::_internal_method() const {
  return method_.Get();
}
inline void GetArtifactMetadataReply::_internal_set_method(const std::string& value) {
  
  method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataReply::_internal_mutable_method() {
  
  return method_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataReply::release_method() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetArtifactMetadataReply.method)
  return method_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetArtifactMetadataReply::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  method_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), method,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (method_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetArtifactMetadataReply.method)
}

// -------------------------------------------------------------------

// GetArtifactMetadataByFileIdRequest

// string user_id = 1 [(.validate.rules) = {
inline void GetArtifactMetadataByFileIdRequest::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& GetArtifactMetadataByFileIdRequest::user_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetArtifactMetadataByFileIdRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetArtifactMetadataByFileIdRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetArtifactMetadataByFileIdRequest.user_id)
}
inline std::string* GetArtifactMetadataByFileIdRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetArtifactMetadataByFileIdRequest.user_id)
  return _s;
}
inline const std::string& GetArtifactMetadataByFileIdRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void GetArtifactMetadataByFileIdRequest::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataByFileIdRequest::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataByFileIdRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetArtifactMetadataByFileIdRequest.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetArtifactMetadataByFileIdRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetArtifactMetadataByFileIdRequest.user_id)
}

// string file_id = 2 [(.validate.rules) = {
inline void GetArtifactMetadataByFileIdRequest::clear_file_id() {
  file_id_.ClearToEmpty();
}
inline const std::string& GetArtifactMetadataByFileIdRequest::file_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetArtifactMetadataByFileIdRequest.file_id)
  return _internal_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetArtifactMetadataByFileIdRequest::set_file_id(ArgT0&& arg0, ArgT... args) {
 
 file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.GetArtifactMetadataByFileIdRequest.file_id)
}
inline std::string* GetArtifactMetadataByFileIdRequest::mutable_file_id() {
  std::string* _s = _internal_mutable_file_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetArtifactMetadataByFileIdRequest.file_id)
  return _s;
}
inline const std::string& GetArtifactMetadataByFileIdRequest::_internal_file_id() const {
  return file_id_.Get();
}
inline void GetArtifactMetadataByFileIdRequest::_internal_set_file_id(const std::string& value) {
  
  file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataByFileIdRequest::_internal_mutable_file_id() {
  
  return file_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetArtifactMetadataByFileIdRequest::release_file_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.GetArtifactMetadataByFileIdRequest.file_id)
  return file_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetArtifactMetadataByFileIdRequest::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    
  } else {
    
  }
  file_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.GetArtifactMetadataByFileIdRequest.file_id)
}

// -------------------------------------------------------------------

// GetArtifactMetadataByFileIdReply

// repeated .bugu.service.v1.GetArtifactMetadataReply artifact_metadata = 1;
inline int GetArtifactMetadataByFileIdReply::_internal_artifact_metadata_size() const {
  return artifact_metadata_.size();
}
inline int GetArtifactMetadataByFileIdReply::artifact_metadata_size() const {
  return _internal_artifact_metadata_size();
}
inline void GetArtifactMetadataByFileIdReply::clear_artifact_metadata() {
  artifact_metadata_.Clear();
}
inline ::bugu::service::v1::GetArtifactMetadataReply* GetArtifactMetadataByFileIdReply::mutable_artifact_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.GetArtifactMetadataByFileIdReply.artifact_metadata)
  return artifact_metadata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bugu::service::v1::GetArtifactMetadataReply >*
GetArtifactMetadataByFileIdReply::mutable_artifact_metadata() {
  // @@protoc_insertion_point(field_mutable_list:bugu.service.v1.GetArtifactMetadataByFileIdReply.artifact_metadata)
  return &artifact_metadata_;
}
inline const ::bugu::service::v1::GetArtifactMetadataReply& GetArtifactMetadataByFileIdReply::_internal_artifact_metadata(int index) const {
  return artifact_metadata_.Get(index);
}
inline const ::bugu::service::v1::GetArtifactMetadataReply& GetArtifactMetadataByFileIdReply::artifact_metadata(int index) const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.GetArtifactMetadataByFileIdReply.artifact_metadata)
  return _internal_artifact_metadata(index);
}
inline ::bugu::service::v1::GetArtifactMetadataReply* GetArtifactMetadataByFileIdReply::_internal_add_artifact_metadata() {
  return artifact_metadata_.Add();
}
inline ::bugu::service::v1::GetArtifactMetadataReply* GetArtifactMetadataByFileIdReply::add_artifact_metadata() {
  ::bugu::service::v1::GetArtifactMetadataReply* _add = _internal_add_artifact_metadata();
  // @@protoc_insertion_point(field_add:bugu.service.v1.GetArtifactMetadataByFileIdReply.artifact_metadata)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bugu::service::v1::GetArtifactMetadataReply >&
GetArtifactMetadataByFileIdReply::artifact_metadata() const {
  // @@protoc_insertion_point(field_list:bugu.service.v1.GetArtifactMetadataByFileIdReply.artifact_metadata)
  return artifact_metadata_;
}

// -------------------------------------------------------------------

// DeleteArtifactMetadataRequest

// string user_id = 1 [(.validate.rules) = {
inline void DeleteArtifactMetadataRequest::clear_user_id() {
  user_id_.ClearToEmpty();
}
inline const std::string& DeleteArtifactMetadataRequest::user_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.DeleteArtifactMetadataRequest.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteArtifactMetadataRequest::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.DeleteArtifactMetadataRequest.user_id)
}
inline std::string* DeleteArtifactMetadataRequest::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.DeleteArtifactMetadataRequest.user_id)
  return _s;
}
inline const std::string& DeleteArtifactMetadataRequest::_internal_user_id() const {
  return user_id_.Get();
}
inline void DeleteArtifactMetadataRequest::_internal_set_user_id(const std::string& value) {
  
  user_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteArtifactMetadataRequest::_internal_mutable_user_id() {
  
  return user_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteArtifactMetadataRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.DeleteArtifactMetadataRequest.user_id)
  return user_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteArtifactMetadataRequest::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  user_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.DeleteArtifactMetadataRequest.user_id)
}

// string artifact_id = 2 [(.validate.rules) = {
inline void DeleteArtifactMetadataRequest::clear_artifact_id() {
  artifact_id_.ClearToEmpty();
}
inline const std::string& DeleteArtifactMetadataRequest::artifact_id() const {
  // @@protoc_insertion_point(field_get:bugu.service.v1.DeleteArtifactMetadataRequest.artifact_id)
  return _internal_artifact_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteArtifactMetadataRequest::set_artifact_id(ArgT0&& arg0, ArgT... args) {
 
 artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bugu.service.v1.DeleteArtifactMetadataRequest.artifact_id)
}
inline std::string* DeleteArtifactMetadataRequest::mutable_artifact_id() {
  std::string* _s = _internal_mutable_artifact_id();
  // @@protoc_insertion_point(field_mutable:bugu.service.v1.DeleteArtifactMetadataRequest.artifact_id)
  return _s;
}
inline const std::string& DeleteArtifactMetadataRequest::_internal_artifact_id() const {
  return artifact_id_.Get();
}
inline void DeleteArtifactMetadataRequest::_internal_set_artifact_id(const std::string& value) {
  
  artifact_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteArtifactMetadataRequest::_internal_mutable_artifact_id() {
  
  return artifact_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteArtifactMetadataRequest::release_artifact_id() {
  // @@protoc_insertion_point(field_release:bugu.service.v1.DeleteArtifactMetadataRequest.artifact_id)
  return artifact_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteArtifactMetadataRequest::set_allocated_artifact_id(std::string* artifact_id) {
  if (artifact_id != nullptr) {
    
  } else {
    
  }
  artifact_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), artifact_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (artifact_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    artifact_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bugu.service.v1.DeleteArtifactMetadataRequest.artifact_id)
}

// -------------------------------------------------------------------

// DeleteArtifactMetadataReply

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace service
}  // namespace bugu

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bugu::service::v1::Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bugu::service::v1::Type>() {
  return ::bugu::service::v1::Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bugu_2eproto
